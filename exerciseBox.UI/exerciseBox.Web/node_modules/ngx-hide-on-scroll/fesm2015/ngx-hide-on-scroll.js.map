{"version":3,"file":"ngx-hide-on-scroll.js","sources":["../../../projects/ngx-hide-on-scroll/src/lib/ngx-hide-on-scroll.directive.ts","../../../projects/ngx-hide-on-scroll/src/lib/ngx-hide-on-scroll.module.ts","../../../projects/ngx-hide-on-scroll/src/public-api.ts","../../../projects/ngx-hide-on-scroll/src/ngx-hide-on-scroll.ts"],"sourcesContent":["import { Directive, ElementRef, AfterViewInit, Inject, PLATFORM_ID, OnDestroy, Input, Renderer2, Output, EventEmitter } from '@angular/core';\r\nimport { fromEvent, Subject } from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  filter,\r\n  map,\r\n  pairwise,\r\n  share,\r\n  takeUntil,\r\n  throttleTime\r\n} from 'rxjs/operators';\r\nimport { isPlatformServer } from '@angular/common';\r\n\r\n// Inspired by: https://netbasal.com/reactive-sticky-header-in-angular-12dbffb3f1d3\r\n\r\n/**\r\n * The `ngxHideOnScroll` directive allows you to hide an html element (e.g. navbar) on scroll down and show it again on scroll up.\r\n */\r\n@Directive({\r\n  selector: '[ngxHideOnScroll]'\r\n})\r\nexport class NgxHideOnScrollDirective implements AfterViewInit, OnDestroy {\r\n\r\n  /**\r\n   * `'Down'`: The element will be hidden on scroll down and it will be shown again on scroll up.<br/>`Up`: The element will be hidden on scroll up and it will be shown again on scroll down.\r\n   */\r\n  @Input() hideOnScroll: 'Down' | 'Up' = 'Down';\r\n\r\n  /**\r\n   * CSS class name added to the element to hide it. When this property is set, `propertyUsedToHide`, `valueWhenHidden`, and `valueWhenShown` have not effect.\r\n   */\r\n  @Input() classNameWhenHidden: string = '';\r\n\r\n  /**\r\n   * The CSS property used to hide/show the element.\r\n   * \r\n   * @default\r\n   * 'transform'\r\n   */\r\n  @Input() propertyUsedToHide: 'transform' | 'top' | 'bottom' | 'height' = 'transform';\r\n\r\n  /**\r\n   * The value of `propertyUsedToHide` when the element is hidden.\r\n   * \r\n   * @default\r\n   * 'translateY(-100%)'\r\n   */\r\n  @Input() valueWhenHidden: string = 'translateY(-100%)';\r\n\r\n  /**\r\n   * The value of `propertyUsedToHide` when the element is shown.\r\n   * \r\n   * @default\r\n   * 'translateY(0)'\r\n   */\r\n  @Input() valueWhenShown: string = 'translateY(0)';\r\n\r\n  /**\r\n   * The selector of the element you want to listen the scroll event, in case it is not the default browser scrolling element (`document.scrollingElement` or `document.documentElement`). For example [` .mat-sidenav-content`]( https://stackoverflow.com/a/52931772/12954396) if you are using [Angular Material Sidenav]( https://material.angular.io/components/sidenav)\r\n   */\r\n  @Input() scrollingElementSelector: string = '';\r\n\r\n  /**\r\n   * Emitted when the element is hidden.\r\n   */\r\n  @Output() eventElementHidden = new EventEmitter<void>();\r\n\r\n  /**\r\n   * Emitted when the element is shown.\r\n   */\r\n  @Output() eventElementShown = new EventEmitter<void>();\r\n\r\n  private unsubscribeNotifier = new Subject();\r\n\r\n  constructor(\r\n    private elementRef: ElementRef<HTMLElement>,\r\n    private renderer2: Renderer2,\r\n    @Inject(PLATFORM_ID) private platformId: string\r\n  ) { }\r\n\r\n  ngAfterViewInit(): void {\r\n    if (isPlatformServer(this.platformId)) {\r\n      return;\r\n    }\r\n\r\n    let elementToListenScrollEvent;\r\n    let scrollingElement: HTMLElement;\r\n    if (!this.scrollingElementSelector) {\r\n      elementToListenScrollEvent = window;\r\n      scrollingElement = this.getDefaultScrollingElement();\r\n    } else {\r\n      scrollingElement = document.querySelector(this.scrollingElementSelector) as HTMLElement;\r\n      if (!scrollingElement) {\r\n        console.error(`NgxHideOnScroll: @Input() scrollingElementSelector\\nElement with selector: \"${this.scrollingElementSelector}\" not found.`);\r\n        return;\r\n      }\r\n      elementToListenScrollEvent = scrollingElement;\r\n    }\r\n\r\n    const scroll$ = fromEvent(elementToListenScrollEvent, 'scroll').pipe(\r\n      takeUntil(this.unsubscribeNotifier),\r\n      throttleTime(50), // only emit every 50 ms\r\n      map(() => scrollingElement.scrollTop), // get vertical scroll position\r\n      pairwise(),  // look at this and the last emitted element\r\n      // compare this and the last element to figure out scrolling direction\r\n      map(([y1, y2]): ScrollDirection => (y2 < y1 ? ScrollDirection.Up : ScrollDirection.Down)),\r\n      distinctUntilChanged(), // only emit when scrolling direction changed\r\n      share() // share a single subscription to the underlying sequence in case of multiple subscribers\r\n    );\r\n\r\n    const scrollUp$ = scroll$.pipe(\r\n      filter(direction => direction === ScrollDirection.Up)\r\n    );\r\n\r\n    const scrollDown$ = scroll$.pipe(\r\n      filter(direction => direction === ScrollDirection.Down)\r\n    );\r\n\r\n    let scrollUpAction: () => void;\r\n    let scrollDownAction: () => void;\r\n    if (this.hideOnScroll === 'Up') {\r\n      scrollUpAction = () => this.hideElement();\r\n      scrollDownAction = () => this.showElement();\r\n    } else {\r\n      scrollUpAction = () => this.showElement();\r\n      scrollDownAction = () => this.hideElement();\r\n    }\r\n\r\n    scrollUp$.subscribe(() => scrollUpAction());\r\n    scrollDown$.subscribe(() => scrollDownAction());\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.unsubscribeNotifier.next();\r\n    this.unsubscribeNotifier.complete();\r\n  }\r\n\r\n  private hideElement(): void {\r\n    const nativeElement = this.elementRef.nativeElement;\r\n    if (this.classNameWhenHidden) {\r\n      this.renderer2.addClass(nativeElement, this.classNameWhenHidden);\r\n    } else {\r\n      this.renderer2.setStyle(nativeElement, this.propertyUsedToHide, this.valueWhenHidden);\r\n    }\r\n    this.eventElementHidden.emit();\r\n  }\r\n\r\n  private showElement(): void {\r\n    const nativeElement = this.elementRef.nativeElement;\r\n    if (this.classNameWhenHidden) {\r\n      this.renderer2.removeClass(nativeElement, this.classNameWhenHidden);\r\n    } else {\r\n      this.renderer2.setStyle(nativeElement, this.propertyUsedToHide, this.valueWhenShown);\r\n    }\r\n    this.eventElementShown.emit();\r\n  }\r\n\r\n  private getDefaultScrollingElement(): HTMLElement {\r\n    return (document.scrollingElement || document.documentElement) as HTMLElement;\r\n  }\r\n}\r\n\r\nenum ScrollDirection {\r\n  Up = 'Up',\r\n  Down = 'Down'\r\n}","import { NgModule } from '@angular/core';\r\nimport { NgxHideOnScrollDirective } from './ngx-hide-on-scroll.directive';\r\n\r\n\r\n@NgModule({\r\n  declarations: [NgxHideOnScrollDirective],\r\n  imports: [],\r\n  exports: [NgxHideOnScrollDirective]\r\n})\r\nexport class NgxHideOnScrollModule { }\r\n","/*\n * Public API Surface of ngx-hide-on-scroll\n */\n\nexport * from './lib/ngx-hide-on-scroll.module';\nexport * from './lib/ngx-hide-on-scroll.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":";;;;;AAaA;AAEA;;;MAMa,wBAAwB;IAqDnC,YACU,UAAmC,EACnC,SAAoB,EACC,UAAkB;QAFvC,eAAU,GAAV,UAAU,CAAyB;QACnC,cAAS,GAAT,SAAS,CAAW;QACC,eAAU,GAAV,UAAU,CAAQ;;;;QAnDxC,iBAAY,GAAkB,MAAM,CAAC;;;;QAKrC,wBAAmB,GAAW,EAAE,CAAC;;;;;;;QAQjC,uBAAkB,GAA8C,WAAW,CAAC;;;;;;;QAQ5E,oBAAe,GAAW,mBAAmB,CAAC;;;;;;;QAQ9C,mBAAc,GAAW,eAAe,CAAC;;;;QAKzC,6BAAwB,GAAW,EAAE,CAAC;;;;QAKrC,uBAAkB,GAAG,IAAI,YAAY,EAAQ,CAAC;;;;QAK9C,sBAAiB,GAAG,IAAI,YAAY,EAAQ,CAAC;QAE/C,wBAAmB,GAAG,IAAI,OAAO,EAAE,CAAC;KAMvC;IAEL,eAAe;QACb,IAAI,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACrC,OAAO;SACR;QAED,IAAI,0BAA0B,CAAC;QAC/B,IAAI,gBAA6B,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC,wBAAwB,EAAE;YAClC,0BAA0B,GAAG,MAAM,CAAC;YACpC,gBAAgB,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;SACtD;aAAM;YACL,gBAAgB,GAAG,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,wBAAwB,CAAgB,CAAC;YACxF,IAAI,CAAC,gBAAgB,EAAE;gBACrB,OAAO,CAAC,KAAK,CAAC,+EAA+E,IAAI,CAAC,wBAAwB,cAAc,CAAC,CAAC;gBAC1I,OAAO;aACR;YACD,0BAA0B,GAAG,gBAAgB,CAAC;SAC/C;QAED,MAAM,OAAO,GAAG,SAAS,CAAC,0BAA0B,EAAE,QAAQ,CAAC,CAAC,IAAI,CAClE,SAAS,CAAC,IAAI,CAAC,mBAAmB,CAAC,EACnC,YAAY,CAAC,EAAE,CAAC;QAChB,GAAG,CAAC,MAAM,gBAAgB,CAAC,SAAS,CAAC;QACrC,QAAQ,EAAE;;QAEV,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,MAAuB,EAAE,GAAG,EAAE,GAAG,eAAe,CAAC,EAAE,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,EACzF,oBAAoB,EAAE;QACtB,KAAK,EAAE;SACR,CAAC;QAEF,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAC5B,MAAM,CAAC,SAAS,IAAI,SAAS,KAAK,eAAe,CAAC,EAAE,CAAC,CACtD,CAAC;QAEF,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAC9B,MAAM,CAAC,SAAS,IAAI,SAAS,KAAK,eAAe,CAAC,IAAI,CAAC,CACxD,CAAC;QAEF,IAAI,cAA0B,CAAC;QAC/B,IAAI,gBAA4B,CAAC;QACjC,IAAI,IAAI,CAAC,YAAY,KAAK,IAAI,EAAE;YAC9B,cAAc,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;YAC1C,gBAAgB,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;SAC7C;aAAM;YACL,cAAc,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;YAC1C,gBAAgB,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;SAC7C;QAED,SAAS,CAAC,SAAS,CAAC,MAAM,cAAc,EAAE,CAAC,CAAC;QAC5C,WAAW,CAAC,SAAS,CAAC,MAAM,gBAAgB,EAAE,CAAC,CAAC;KACjD;IAED,WAAW;QACT,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAC;QAChC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,CAAC;KACrC;IAEO,WAAW;QACjB,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;QACpD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC5B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;SAClE;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;SACvF;QACD,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC;KAChC;IAEO,WAAW;QACjB,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;QACpD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC5B,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,aAAa,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;SACrE;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;SACtF;QACD,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC;KAC/B;IAEO,0BAA0B;QAChC,QAAQ,QAAQ,CAAC,gBAAgB,IAAI,QAAQ,CAAC,eAAe,EAAiB;KAC/E;;;YA7IF,SAAS,SAAC;gBACT,QAAQ,EAAE,mBAAmB;aAC9B;;;YApBmB,UAAU;YAAwD,SAAS;yCA6E1F,MAAM,SAAC,WAAW;;;2BAnDpB,KAAK;kCAKL,KAAK;iCAQL,KAAK;8BAQL,KAAK;6BAQL,KAAK;uCAKL,KAAK;iCAKL,MAAM;gCAKN,MAAM;;AA4FT,IAAK,eAGJ;AAHD,WAAK,eAAe;IAClB,4BAAS,CAAA;IACT,gCAAa,CAAA;AACf,CAAC,EAHI,eAAe,KAAf,eAAe;;MCzJP,qBAAqB;;;YALjC,QAAQ,SAAC;gBACR,YAAY,EAAE,CAAC,wBAAwB,CAAC;gBACxC,OAAO,EAAE,EAAE;gBACX,OAAO,EAAE,CAAC,wBAAwB,CAAC;aACpC;;;ACRD;;;;ACAA;;;;;;"}
import { parseContent } from './parsers';
import defaultSchema from './schema';
const isEmptyInputValue = (value) => {
    // we don't check for string here so it also works with arrays
    return value === null || value.length === 0;
};
const hasValidLength = (value) => {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value !== null && typeof value.length === 'number';
};
const isDocEmpty = (doc) => {
    if (!doc) {
        return true;
    }
    const { childCount, firstChild } = doc;
    return Boolean(childCount === 1 && firstChild?.isTextblock && firstChild.content.size === 0);
};
// @dynamic
export class Validators {
    static required(userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const isEmpty = isDocEmpty(doc);
            if (!isEmpty) {
                return null;
            }
            return {
                required: true,
            };
        };
    }
    static maxLength(maxLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (hasValidLength(value) && value.length > maxLength) {
                return {
                    maxlength: {
                        requiredLength: maxLength,
                        actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
    static minLength(minLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (isEmptyInputValue(value) || !hasValidLength(value)) {
                // don't validate empty values to allow optional controls
                // don't validate values without `length` property
                return null;
            }
            if (value.length < minLength) {
                return {
                    minlength: {
                        requiredLength: minLength, actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1lZGl0b3Ivc3JjL2xpYi92YWxpZGF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDekMsT0FBTyxhQUFhLE1BQU0sVUFBVSxDQUFDO0FBSXJDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNoRCw4REFBOEQ7SUFDOUQsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQztBQUVGLE1BQU0sY0FBYyxHQUFHLENBQUMsS0FBVSxFQUFXLEVBQUU7SUFDN0Msd0ZBQXdGO0lBQ3hGLE9BQU8sS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQzVELENBQUMsQ0FBQztBQUVGLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBMkIsRUFBVyxFQUFFO0lBQzFELElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNULE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELE1BQU0sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ3ZDLE9BQU8sT0FBTyxDQUFDLFVBQVUsS0FBSyxDQUFDLElBQUksVUFBVSxFQUFFLFdBQVcsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMvRixDQUFDLENBQUM7QUFFRixXQUFXO0FBQ1gsTUFBTSxPQUFPLFVBQVU7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFtQjtRQUNqQyxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUMzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVoQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2IsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsT0FBTztnQkFDTCxRQUFRLEVBQUUsSUFBSTthQUNmLENBQUM7UUFDSixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFpQixFQUFFLFVBQW1CO1FBQ3JELE9BQU8sQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQzNELE1BQU0sTUFBTSxHQUFHLFVBQVUsSUFBSSxhQUFhLENBQUM7WUFDM0MsTUFBTSxHQUFHLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFaEQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQztZQUU5QixJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO2dCQUN0RCxPQUFPO29CQUNMLFNBQVMsRUFBRTt3QkFDVCxjQUFjLEVBQUUsU0FBUzt3QkFDekIsWUFBWSxFQUFFLEtBQUssQ0FBQyxNQUFNO3FCQUMzQjtpQkFDRixDQUFDO1lBQ0osQ0FBQztZQUVELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBaUIsRUFBRSxVQUFtQjtRQUNyRCxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUMzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFFOUIsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUN2RCx5REFBeUQ7Z0JBQ3pELGtEQUFrRDtnQkFDbEQsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO2dCQUM3QixPQUFPO29CQUNMLFNBQVMsRUFBRTt3QkFDVCxjQUFjLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsTUFBTTtxQkFDdEQ7aUJBQ0YsQ0FBQztZQUNKLENBQUM7WUFFRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdG9yRm4gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTY2hlbWEsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG5pbXBvcnQgeyBwYXJzZUNvbnRlbnQgfSBmcm9tICcuL3BhcnNlcnMnO1xuaW1wb3J0IGRlZmF1bHRTY2hlbWEgZnJvbSAnLi9zY2hlbWEnO1xuXG50eXBlIFZhbGlkYXRpb25FcnJvcnMgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG5jb25zdCBpc0VtcHR5SW5wdXRWYWx1ZSA9ICh2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gIC8vIHdlIGRvbid0IGNoZWNrIGZvciBzdHJpbmcgaGVyZSBzbyBpdCBhbHNvIHdvcmtzIHdpdGggYXJyYXlzXG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XG59O1xuXG5jb25zdCBoYXNWYWxpZExlbmd0aCA9ICh2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gIC8vIG5vbi1zdHJpY3QgY29tcGFyaXNvbiBpcyBpbnRlbnRpb25hbCwgdG8gY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXNcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEb2NFbXB0eSA9IChkb2M6IFByb3NlTWlycm9yTm9kZSB8IG51bGwpOiBib29sZWFuID0+IHtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hpbGRDb3VudCwgZmlyc3RDaGlsZCB9ID0gZG9jO1xuICByZXR1cm4gQm9vbGVhbihjaGlsZENvdW50ID09PSAxICYmIGZpcnN0Q2hpbGQ/LmlzVGV4dGJsb2NrICYmIGZpcnN0Q2hpbGQuY29udGVudC5zaXplID09PSAwKTtcbn07XG5cbi8vIEBkeW5hbWljXG5leHBvcnQgY2xhc3MgVmFsaWRhdG9ycyB7XG4gIHN0YXRpYyByZXF1aXJlZCh1c2VyU2NoZW1hPzogU2NoZW1hKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gdXNlclNjaGVtYSB8fCBkZWZhdWx0U2NoZW1hO1xuICAgICAgY29uc3QgZG9jID0gcGFyc2VDb250ZW50KGNvbnRyb2wudmFsdWUsIHNjaGVtYSk7XG5cbiAgICAgIGNvbnN0IGlzRW1wdHkgPSBpc0RvY0VtcHR5KGRvYyk7XG5cbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbWF4TGVuZ3RoKG1heExlbmd0aDogbnVtYmVyLCB1c2VyU2NoZW1hPzogU2NoZW1hKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gdXNlclNjaGVtYSB8fCBkZWZhdWx0U2NoZW1hO1xuICAgICAgY29uc3QgZG9jID0gcGFyc2VDb250ZW50KGNvbnRyb2wudmFsdWUsIHNjaGVtYSk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZG9jLnRleHRDb250ZW50O1xuXG4gICAgICBpZiAoaGFzVmFsaWRMZW5ndGgodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1heGxlbmd0aDoge1xuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGg6IG1heExlbmd0aCxcbiAgICAgICAgICAgIGFjdHVhbExlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbWluTGVuZ3RoKG1pbkxlbmd0aDogbnVtYmVyLCB1c2VyU2NoZW1hPzogU2NoZW1hKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gdXNlclNjaGVtYSB8fCBkZWZhdWx0U2NoZW1hO1xuICAgICAgY29uc3QgZG9jID0gcGFyc2VDb250ZW50KGNvbnRyb2wudmFsdWUsIHNjaGVtYSk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZG9jLnRleHRDb250ZW50O1xuXG4gICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHx8ICFoYXNWYWxpZExlbmd0aCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIHZhbHVlcyB3aXRob3V0IGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWlubGVuZ3RoOiB7XG4gICAgICAgICAgICByZXF1aXJlZExlbmd0aDogbWluTGVuZ3RoLCBhY3R1YWxMZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG59XG4iXX0=
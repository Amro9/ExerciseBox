import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, ViewChild, ApplicationRef, createComponent, forwardRef, ViewEncapsulation, Injectable, Optional, Pipe, HostListener, HostBinding, NgModule, InjectionToken } from '@angular/core';
import * as i4 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormGroup, FormControl, Validators as Validators$1, ReactiveFormsModule } from '@angular/forms';
import { Subject, isObservable, of, fromEvent, asyncScheduler } from 'rxjs';
import { takeUntil, throttleTime } from 'rxjs/operators';
import { NgxEditorError, clamp, uniq, isNil } from 'ngx-editor/utils';
import { Plugin, PluginKey, NodeSelection, Selection, EditorState } from 'prosemirror-state';
import { DecorationSet, Decoration, EditorView } from 'prosemirror-view';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import { Fragment, Slice, DOMSerializer, DOMParser } from 'prosemirror-model';
import { schema } from 'ngx-editor/schema';
export { marks, nodes, schema } from 'ngx-editor/schema';
import { toggleMark, lift, wrapIn, setBlockType, newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock, chainCommands, exitCode, baseKeymap } from 'prosemirror-commands';
import { applyMark, removeLink, removeMark } from 'ngx-editor/commands';
import { isMarkActive, isNodeActive, canInsert, getSelectionNodes, getSelectionMarks, markInputRule } from 'ngx-editor/helpers';
import { liftListItem, wrapInList, splitListItem, sinkListItem } from 'prosemirror-schema-list';
import { undo as undo$1, redo as redo$1, history } from 'prosemirror-history';
import * as i1 from '@angular/platform-browser';
import { computePosition, offset, autoPlacement, detectOverflow } from '@floating-ui/dom';
import { keymap } from 'prosemirror-keymap';
import { wrappingInputRule, textblockTypeInputRule, smartQuotes, ellipsis, emDash, inputRules } from 'prosemirror-inputrules';

const editablePlugin = (editable = true) => {
    return new Plugin({
        key: new PluginKey('editable'),
        state: {
            init() {
                return editable;
            },
            apply(tr, previousVal) {
                return tr.getMeta('UPDATE_EDITABLE') ?? previousVal;
            },
        },
        props: {
            editable(state) {
                return this.getState(state);
            },
            attributes(state) {
                const isEnabled = this.getState(state);
                if (isEnabled) {
                    return null;
                }
                return {
                    class: 'NgxEditor__Content--Disabled',
                };
            },
        },
    });
};

const PLACEHOLDER_CLASSNAME = 'NgxEditor__Placeholder';
const placeholderPlugin = (text) => {
    return new Plugin({
        key: new PluginKey('placeholder'),
        state: {
            init() {
                return text ?? '';
            },
            apply(tr, previousVal) {
                const placeholder = tr.getMeta('UPDATE_PLACEHOLDER') ?? previousVal;
                return placeholder;
            },
        },
        props: {
            decorations(state) {
                const { doc } = state;
                const { textContent, childCount } = doc;
                const placeholder = this.getState(state);
                if (!placeholder || childCount > 1) {
                    return DecorationSet.empty;
                }
                const decorations = [];
                const decorate = (node, pos) => {
                    if (node.type.isBlock && node.childCount === 0 && textContent.length === 0) {
                        const from = pos;
                        const to = pos + node.nodeSize;
                        const placeholderNode = Decoration.node(from, to, {
                            'class': PLACEHOLDER_CLASSNAME,
                            'data-placeholder': placeholder,
                            'data-align': node.attrs['align'] ?? null,
                        });
                        decorations.push(placeholderNode);
                    }
                    return false;
                };
                doc.descendants(decorate);
                return DecorationSet.create(doc, decorations);
            },
        },
    });
};

const attributesPlugin = (attributes = {}) => {
    return new Plugin({
        key: new PluginKey('attributes'),
        props: {
            attributes,
        },
    });
};

const focusPlugin = (cb) => {
    return new Plugin({
        key: new PluginKey('focus'),
        props: {
            handleDOMEvents: {
                focus: () => {
                    cb();
                    return false;
                },
            },
        },
    });
};

const blurPlugin = (cb) => {
    return new Plugin({
        key: new PluginKey('blur'),
        props: {
            handleDOMEvents: {
                blur: () => {
                    cb();
                    return false;
                },
            },
        },
    });
};

class ImageViewComponent {
    constructor() {
        this.alt = '';
        this.title = '';
        this.outerWidth = '';
        this.selected = false;
        this.imageResize = new EventEmitter();
    }
    startResizing(e, direction) {
        e.preventDefault();
        this.resizeImage(e, direction);
    }
    resizeImage(evt, direction) {
        const startX = evt.pageX;
        const startWidth = this.imgEl.nativeElement.clientWidth;
        const isLeftResize = direction === 'left';
        const { width } = window.getComputedStyle(this.view.dom);
        const editorWidth = parseInt(width, 10);
        const onMouseMove = (e) => {
            const currentX = e.pageX;
            const diffInPx = currentX - startX;
            const computedWidth = isLeftResize ? startWidth - diffInPx : startWidth + diffInPx;
            // prevent image overflow the editor
            // prevent resizng below 20px
            if (computedWidth > editorWidth || computedWidth < 20) {
                return;
            }
            this.outerWidth = `${computedWidth}px`;
        };
        const onMouseUp = (e) => {
            e.preventDefault();
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            this.imageResize.emit();
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ImageViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: ImageViewComponent, selector: "ngx-image-view", inputs: { src: "src", alt: "alt", title: "title", outerWidth: "outerWidth", selected: "selected", view: "view" }, outputs: { imageResize: "imageResize" }, viewQueries: [{ propertyName: "imgEl", first: true, predicate: ["imgEl"], descendants: true, static: true }], ngImport: i0, template: "<span class=\"NgxEditor__ImageWrapper\" [ngClass]=\"{ 'NgxEditor__Resizer--Active': selected }\" [style.width]=\"outerWidth\">\n  <span class=\"NgxEditor__ResizeHandle\" *ngIf=\"selected\">\n    <span class=\"NgxEditor__ResizeHandle--TL\" (mousedown)=\"startResizing($event, 'left')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--TR\" (mousedown)=\"startResizing($event, 'right')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--BL\" (mousedown)=\"startResizing($event, 'left')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--BR\" (mousedown)=\"startResizing($event, 'right')\"></span>\n  </span>\n  <img [src]=\"src\" [alt]=\"alt\" [title]=\"title\" #imgEl />\n</span>\n", styles: ["*,*:before,*:after{box-sizing:border-box}img{width:100%;height:100%}.NgxEditor__ImageWrapper{position:relative;display:inline-block;line-height:0;padding:2px}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active{padding:1px;border:1px solid #1a73e8}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle{position:absolute;height:100%;width:100%}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{position:absolute;width:7px;height:7px;background-color:#1a73e8;border:1px solid white}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{bottom:-5px;right:-5px;cursor:se-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{top:-5px;right:-5px;cursor:ne-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL{top:-5px;left:-5px;cursor:nw-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL{bottom:-5px;left:-5px;cursor:sw-resize}\n"], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ImageViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-image-view', template: "<span class=\"NgxEditor__ImageWrapper\" [ngClass]=\"{ 'NgxEditor__Resizer--Active': selected }\" [style.width]=\"outerWidth\">\n  <span class=\"NgxEditor__ResizeHandle\" *ngIf=\"selected\">\n    <span class=\"NgxEditor__ResizeHandle--TL\" (mousedown)=\"startResizing($event, 'left')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--TR\" (mousedown)=\"startResizing($event, 'right')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--BL\" (mousedown)=\"startResizing($event, 'left')\"></span>\n    <span class=\"NgxEditor__ResizeHandle--BR\" (mousedown)=\"startResizing($event, 'right')\"></span>\n  </span>\n  <img [src]=\"src\" [alt]=\"alt\" [title]=\"title\" #imgEl />\n</span>\n", styles: ["*,*:before,*:after{box-sizing:border-box}img{width:100%;height:100%}.NgxEditor__ImageWrapper{position:relative;display:inline-block;line-height:0;padding:2px}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active{padding:1px;border:1px solid #1a73e8}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle{position:absolute;height:100%;width:100%}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{position:absolute;width:7px;height:7px;background-color:#1a73e8;border:1px solid white}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{bottom:-5px;right:-5px;cursor:se-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{top:-5px;right:-5px;cursor:ne-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL{top:-5px;left:-5px;cursor:nw-resize}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL{bottom:-5px;left:-5px;cursor:sw-resize}\n"] }]
        }], propDecorators: { src: [{
                type: Input
            }], alt: [{
                type: Input
            }], title: [{
                type: Input
            }], outerWidth: [{
                type: Input
            }], selected: [{
                type: Input
            }], view: [{
                type: Input
            }], imageResize: [{
                type: Output
            }], imgEl: [{
                type: ViewChild,
                args: ['imgEl', { static: true }]
            }] } });

class ImageRezieView {
    constructor(node, view, getPos, injector) {
        this.updating = false;
        this.handleResize = () => {
            if (this.updating) {
                return;
            }
            const { state, dispatch } = this.view;
            const { tr } = state;
            const transaction = tr.setNodeMarkup(this.getPos(), undefined, {
                ...this.node.attrs,
                width: this.imageComponentRef.instance.outerWidth,
            });
            const resolvedPos = transaction.doc.resolve(this.getPos());
            const newSelection = new NodeSelection(resolvedPos);
            transaction.setSelection(newSelection);
            dispatch(transaction);
        };
        this.applicationRef = injector.get(ApplicationRef);
        // create component ref
        this.imageComponentRef = createComponent(ImageViewComponent, {
            environmentInjector: this.applicationRef.injector,
        });
        // Attach to the view so that the change detector knows to run
        this.applicationRef.attachView(this.imageComponentRef.hostView);
        this.setNodeAttributes(node.attrs);
        this.imageComponentRef.instance.view = view;
        this.dom = this.imageComponentRef.location.nativeElement;
        this.view = view;
        this.node = node;
        this.getPos = getPos;
        this.resizeSubscription = this.imageComponentRef.instance.imageResize.subscribe(() => {
            this.handleResize();
        });
    }
    computeChanges(prevAttrs, newAttrs) {
        return JSON.stringify(prevAttrs) === JSON.stringify(newAttrs);
    }
    setNodeAttributes(attrs) {
        this.imageComponentRef.instance.src = attrs['src'];
        this.imageComponentRef.instance.alt = attrs['alt'];
        this.imageComponentRef.instance.title = attrs['title'];
        this.imageComponentRef.instance.outerWidth = attrs['width'];
    }
    update(node) {
        if (node.type !== this.node.type) {
            return false;
        }
        this.node = node;
        const changed = this.computeChanges(this.node.attrs, node.attrs);
        if (changed) {
            this.updating = true;
            this.setNodeAttributes(node.attrs);
            this.updating = false;
        }
        return true;
    }
    ignoreMutation() {
        return true;
    }
    selectNode() {
        this.imageComponentRef.instance.selected = true;
    }
    deselectNode() {
        this.imageComponentRef.instance.selected = false;
    }
    destroy() {
        this.resizeSubscription.unsubscribe();
        this.applicationRef.detachView(this.imageComponentRef.hostView);
    }
}
const imageResizePlugin = (injector) => {
    return new Plugin({
        key: new PluginKey('image-resize'),
        props: {
            nodeViews: {
                image: (node, view, getPos) => {
                    return new ImageRezieView(node, view, getPos, injector);
                },
            },
        },
    });
};

const HTTP_LINK_REGEX = /(?:https?:\/\/)?[\w-]+(?:\.[\w-]+)+\.?(?:\d+)?(?:\/\S*)?$/;
const linkify = (fragment) => {
    const linkified = [];
    fragment.forEach((child) => {
        if (child.isText) {
            const text = child.text;
            let pos = 0;
            const match = HTTP_LINK_REGEX.exec(text);
            if (match) {
                const start = match.index;
                const end = start + match[0].length;
                const { link } = child.type.schema.marks;
                if (start > 0) {
                    linkified.push(child.cut(pos, start));
                }
                const urlText = text.slice(start, end);
                linkified.push(child.cut(start, end).mark(link.create({ href: urlText }).addToSet(child.marks)));
                pos = end;
            }
            if (pos < text.length) {
                linkified.push(child.cut(pos));
            }
        }
        else {
            linkified.push(child.copy(linkify(child.content)));
        }
    });
    return Fragment.fromArray(linkified);
};
const linkifyPlugin = () => {
    return new Plugin({
        key: new PluginKey('linkify'),
        props: {
            transformPasted: (slice) => {
                return new Slice(linkify(slice.content), slice.openStart, slice.openEnd);
            },
        },
    });
};

const isString = (value) => {
    return typeof value === 'string';
};

const getTrustedTypes = () => {
    return window.trustedTypes;
};
const isTrustedHtml = (value) => {
    return getTrustedTypes()?.isHTML(value) ?? false;
};
const isHtml = (value) => {
    return isString(value) || isTrustedHtml(value);
};

const emptyDoc = {
    type: 'doc',
    content: [
        {
            type: 'paragraph',
        },
    ],
};
// https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment
const toHTML = (json, inputSchema) => {
    const schema$1 = inputSchema ?? schema;
    const contentNode = schema$1.nodeFromJSON(json);
    const html = DOMSerializer.fromSchema(schema$1).serializeFragment(contentNode.content);
    const div = document.createElement('div');
    div.appendChild(html);
    return div.innerHTML;
};
const toDoc = (html, inputSchema, options) => {
    const schema$1 = inputSchema ?? schema;
    const el = document.createElement('div');
    el.innerHTML = html;
    return DOMParser.fromSchema(schema$1).parse(el, options).toJSON();
};
const parseContent = (value, schema, options) => {
    if (!value) {
        return schema.nodeFromJSON(emptyDoc);
    }
    if (!isHtml(value)) {
        return schema.nodeFromJSON(value);
    }
    const docJson = toDoc(value, schema, options);
    return schema.nodeFromJSON(docJson);
};

class NgxEditorComponent {
    constructor(renderer, injector, elementRef) {
        this.renderer = renderer;
        this.injector = injector;
        this.elementRef = elementRef;
        this.placeholder = 'Type Here...';
        this.focusOut = new EventEmitter();
        this.focusIn = new EventEmitter();
        this.unsubscribe = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        if (!this.outputFormat && isHtml(value)) {
            this.outputFormat = 'html';
        }
        this.editor.setContent(value ?? emptyDoc);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.setMeta('UPDATE_EDITABLE', !isDisabled);
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    handleChange(jsonDoc) {
        if (this.outputFormat === 'html') {
            const html = toHTML(jsonDoc, this.editor.schema);
            this.onChange(html);
            return;
        }
        this.onChange(jsonDoc);
    }
    setMeta(key, value) {
        const { dispatch, state: { tr } } = this.editor.view;
        dispatch(tr.setMeta(key, value));
    }
    setPlaceholder(placeholder) {
        this.setMeta('UPDATE_PLACEHOLDER', placeholder);
    }
    registerPlugins() {
        this.editor.registerPlugin(editablePlugin());
        this.editor.registerPlugin(placeholderPlugin(this.placeholder));
        this.editor.registerPlugin(attributesPlugin({
            class: 'NgxEditor__Content',
        }));
        this.editor.registerPlugin(focusPlugin(() => {
            this.focusIn.emit();
        }));
        this.editor.registerPlugin(blurPlugin(() => {
            this.focusOut.emit();
            this.onTouched();
        }));
        if (this.editor.features.resizeImage) {
            this.editor.registerPlugin(imageResizePlugin(this.injector));
        }
        if (this.editor.features.linkOnPaste) {
            this.editor.registerPlugin(linkifyPlugin());
        }
    }
    ngOnInit() {
        if (!this.editor) {
            throw new NgxEditorError('Required editor instance for initializing editor component');
        }
        this.registerPlugins();
        this.renderer.appendChild(this.ngxEditor.nativeElement, this.editor.view.dom);
        this.editor.valueChanges
            .pipe(takeUntil(this.unsubscribe))
            .subscribe((jsonDoc) => {
            this.handleChange(jsonDoc);
        });
    }
    ngOnChanges(changes) {
        if (changes['placeholder'] && !changes['placeholder'].isFirstChange()) {
            this.setPlaceholder(changes['placeholder'].currentValue);
        }
    }
    ngOnDestroy() {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorComponent, deps: [{ token: i0.Renderer2 }, { token: i0.Injector }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: NgxEditorComponent, selector: "ngx-editor", inputs: { editor: "editor", outputFormat: "outputFormat", placeholder: "placeholder" }, outputs: { focusOut: "focusOut", focusIn: "focusIn" }, providers: [{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NgxEditorComponent),
                multi: true,
            }], viewQueries: [{ propertyName: "ngxEditor", first: true, predicate: ["ngxEditor"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"NgxEditor\" #ngxEditor>\n  <ng-content></ng-content>\n</div>\n", styles: [":root{--ngx-editor-border-radius: 4px;--ngx-editor-background-color: #fff;--ngx-editor-text-color: #000;--ngx-editor-placeholder-color: #6c757d;--ngx-editor-border-color: rgba(0, 0, 0, .2);--ngx-editor-wrapper-border-color: rgba(0, 0, 0, .2);--ngx-editor-menubar-bg-color: #fff;--ngx-editor-menubar-padding: 3px;--ngx-editor-menubar-height: 30px;--ngx-editor-blockquote-color: #ddd;--ngx-editor-blockquote-border-width: 3px;--ngx-editor-icon-size: 30px;--ngx-editor-popup-bg-color: #fff;--ngx-editor-popup-border-radius: 4px;--ngx-editor-popup-shadow: rgba(60, 64, 67, .15) 0px 2px 6px 2px;--ngx-editor-menu-item-border-radius: 2px;--ngx-editor-menu-item-active-color: #1a73e8;--ngx-editor-menu-item-hover-bg-color: #f1f1f1;--ngx-editor-menu-item-active-bg-color: #e8f0fe;--ngx-editor-seperator-color: #ccc;--ngx-editor-bubble-bg-color: #000;--ngx-editor-bubble-text-color: #fff;--ngx-editor-bubble-item-hover-color: #636262;--ngx-editor-bubble-seperator-color: #fff;--ngx-editor-focus-ring-color: #5e9ed6;--ngx-editor-error-color: red;--ngx-editor-click-pointer: default}.NgxEditor{background:var(--ngx-editor-background-color);color:var(--ngx-editor-text-color);background-clip:padding-box;border-radius:var(--ngx-editor-border-radius);border:1px solid var(--ngx-editor-border-color);position:relative}.NgxEditor--Disabled{opacity:.5!important;pointer-events:none!important}.NgxEditor__Placeholder:before{color:var(--ngx-editor-placeholder-color);opacity:1;-webkit-user-select:none;user-select:none;position:absolute;cursor:text;content:attr(data-placeholder)}.NgxEditor__Placeholder[data-align=right]:before{position:relative}.NgxEditor__Content{padding:8px;white-space:pre-wrap;outline:none;font-variant-ligatures:none;font-feature-settings:\"liga\" 0}.NgxEditor__Content p{margin:0 0 10px}.NgxEditor__Content blockquote{padding-left:16px;border-left:var(--ngx-editor-blockquote-border-width) solid var(--ngx-editor-blockquote-color);margin-left:0;margin-right:0}.NgxEditor__Content--Disabled{-webkit-user-select:none;user-select:none;pointer-events:none}.NgxEditor__Wrapper{border:1px solid var(--ngx-editor-wrapper-border-color);border-radius:var(--ngx-editor-border-radius)}.NgxEditor__Wrapper .NgxEditor__MenuBar{border-top-left-radius:var(--ngx-editor-border-radius);border-top-right-radius:var(--ngx-editor-border-radius);border-bottom:1px solid var(--ngx-editor-border-color)}.NgxEditor__Wrapper .NgxEditor{border-top-left-radius:0;border-top-right-radius:0;border:none}.NgxEditor__MenuBar{display:flex;flex-wrap:wrap;padding:var(--ngx-editor-menubar-padding);background-color:var(--ngx-editor-menubar-bg-color);gap:.25rem .1rem}.NgxEditor__MenuBar button:not(:disabled),.NgxEditor__MenuBar [role=button]:not(:disabled){cursor:var(--ngx-editor-click-pointer, default)}.NgxEditor__MenuItem{display:flex;align-items:center;justify-content:center;position:relative;flex-shrink:0}.NgxEditor__MenuItem.NgxEditor__MenuItem--IconContainer{display:flex;align-items:center;justify-content:center}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon{all:unset;appearance:none;height:var(--ngx-editor-icon-size);width:var(--ngx-editor-icon-size);transition:.2s ease-in-out;display:inline-flex;align-items:center;justify-content:center;border-radius:var(--ngx-editor-menu-item-border-radius)}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 5px}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active,.NgxEditor__MenuItem .NgxEditor__MenuItem--Active{background-color:var(--ngx-editor-menu-item-active-bg-color);color:var(--ngx-editor-menu-item-active-color)}.NgxEditor__Dropdown{min-width:64px;position:relative;display:flex;align-items:center;flex-shrink:0}.NgxEditor__Dropdown:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{all:unset;appearance:none;display:flex;align-items:center;justify-content:center;padding:0 5px;height:100%;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{display:inline-block;content:\"\";margin-left:24px;vertical-align:4px;border-top:4px solid;border-right:4px solid transparent;border-bottom:0;border-left:4px solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{position:absolute;left:0;box-shadow:var(--ngx-editor-popup-shadow);border-radius:var(--ngx-editor-popup-border-radius);background-color:var(--ngx-editor-popup-bg-color);z-index:10;width:100%;top:calc(var(--ngx-editor-menubar-height) + 2px);display:flex;flex-direction:column}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{all:unset;appearance:none;padding:8px;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Selected,.NgxEditor__Dropdown .NgxEditor__Dropdown--Open{color:var(--ngx-editor-menu-item-active-color);background-color:var(--ngx-editor-menu-item-active-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:var(--ngx-editor-menu-item-active-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--DropdownMenu{top:unset;bottom:calc(var(--ngx-editor-menubar-height) + 2px)}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--Text:after{transform:rotate(180deg)}.NgxEditor__MenuBar--Reverse .NgxEditor__Popup{top:unset;bottom:calc(var(--ngx-editor-menubar-height) + 2px)}.NgxEditor__Popup{position:absolute;top:calc(var(--ngx-editor-menubar-height) + 2px);box-shadow:var(--ngx-editor-popup-shadow);border-radius:var(--ngx-editor-popup-border-radius);background-color:var(--ngx-editor-popup-bg-color);z-index:10;min-width:192px;padding:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid var(--ngx-editor-seperator-color);margin:0 5px}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:var(--ngx-editor-error-color)}\n"], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-editor', providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NgxEditorComponent),
                            multi: true,
                        }], encapsulation: ViewEncapsulation.None, template: "<div class=\"NgxEditor\" #ngxEditor>\n  <ng-content></ng-content>\n</div>\n", styles: [":root{--ngx-editor-border-radius: 4px;--ngx-editor-background-color: #fff;--ngx-editor-text-color: #000;--ngx-editor-placeholder-color: #6c757d;--ngx-editor-border-color: rgba(0, 0, 0, .2);--ngx-editor-wrapper-border-color: rgba(0, 0, 0, .2);--ngx-editor-menubar-bg-color: #fff;--ngx-editor-menubar-padding: 3px;--ngx-editor-menubar-height: 30px;--ngx-editor-blockquote-color: #ddd;--ngx-editor-blockquote-border-width: 3px;--ngx-editor-icon-size: 30px;--ngx-editor-popup-bg-color: #fff;--ngx-editor-popup-border-radius: 4px;--ngx-editor-popup-shadow: rgba(60, 64, 67, .15) 0px 2px 6px 2px;--ngx-editor-menu-item-border-radius: 2px;--ngx-editor-menu-item-active-color: #1a73e8;--ngx-editor-menu-item-hover-bg-color: #f1f1f1;--ngx-editor-menu-item-active-bg-color: #e8f0fe;--ngx-editor-seperator-color: #ccc;--ngx-editor-bubble-bg-color: #000;--ngx-editor-bubble-text-color: #fff;--ngx-editor-bubble-item-hover-color: #636262;--ngx-editor-bubble-seperator-color: #fff;--ngx-editor-focus-ring-color: #5e9ed6;--ngx-editor-error-color: red;--ngx-editor-click-pointer: default}.NgxEditor{background:var(--ngx-editor-background-color);color:var(--ngx-editor-text-color);background-clip:padding-box;border-radius:var(--ngx-editor-border-radius);border:1px solid var(--ngx-editor-border-color);position:relative}.NgxEditor--Disabled{opacity:.5!important;pointer-events:none!important}.NgxEditor__Placeholder:before{color:var(--ngx-editor-placeholder-color);opacity:1;-webkit-user-select:none;user-select:none;position:absolute;cursor:text;content:attr(data-placeholder)}.NgxEditor__Placeholder[data-align=right]:before{position:relative}.NgxEditor__Content{padding:8px;white-space:pre-wrap;outline:none;font-variant-ligatures:none;font-feature-settings:\"liga\" 0}.NgxEditor__Content p{margin:0 0 10px}.NgxEditor__Content blockquote{padding-left:16px;border-left:var(--ngx-editor-blockquote-border-width) solid var(--ngx-editor-blockquote-color);margin-left:0;margin-right:0}.NgxEditor__Content--Disabled{-webkit-user-select:none;user-select:none;pointer-events:none}.NgxEditor__Wrapper{border:1px solid var(--ngx-editor-wrapper-border-color);border-radius:var(--ngx-editor-border-radius)}.NgxEditor__Wrapper .NgxEditor__MenuBar{border-top-left-radius:var(--ngx-editor-border-radius);border-top-right-radius:var(--ngx-editor-border-radius);border-bottom:1px solid var(--ngx-editor-border-color)}.NgxEditor__Wrapper .NgxEditor{border-top-left-radius:0;border-top-right-radius:0;border:none}.NgxEditor__MenuBar{display:flex;flex-wrap:wrap;padding:var(--ngx-editor-menubar-padding);background-color:var(--ngx-editor-menubar-bg-color);gap:.25rem .1rem}.NgxEditor__MenuBar button:not(:disabled),.NgxEditor__MenuBar [role=button]:not(:disabled){cursor:var(--ngx-editor-click-pointer, default)}.NgxEditor__MenuItem{display:flex;align-items:center;justify-content:center;position:relative;flex-shrink:0}.NgxEditor__MenuItem.NgxEditor__MenuItem--IconContainer{display:flex;align-items:center;justify-content:center}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon{all:unset;appearance:none;height:var(--ngx-editor-icon-size);width:var(--ngx-editor-icon-size);transition:.2s ease-in-out;display:inline-flex;align-items:center;justify-content:center;border-radius:var(--ngx-editor-menu-item-border-radius)}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__MenuItem .NgxEditor__MenuItem--Icon:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 5px}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active,.NgxEditor__MenuItem .NgxEditor__MenuItem--Active{background-color:var(--ngx-editor-menu-item-active-bg-color);color:var(--ngx-editor-menu-item-active-color)}.NgxEditor__Dropdown{min-width:64px;position:relative;display:flex;align-items:center;flex-shrink:0}.NgxEditor__Dropdown:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{all:unset;appearance:none;display:flex;align-items:center;justify-content:center;padding:0 5px;height:100%;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{display:inline-block;content:\"\";margin-left:24px;vertical-align:4px;border-top:4px solid;border-right:4px solid transparent;border-bottom:0;border-left:4px solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{position:absolute;left:0;box-shadow:var(--ngx-editor-popup-shadow);border-radius:var(--ngx-editor-popup-border-radius);background-color:var(--ngx-editor-popup-bg-color);z-index:10;width:100%;top:calc(var(--ngx-editor-menubar-height) + 2px);display:flex;flex-direction:column}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{all:unset;appearance:none;padding:8px;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Selected,.NgxEditor__Dropdown .NgxEditor__Dropdown--Open{color:var(--ngx-editor-menu-item-active-color);background-color:var(--ngx-editor-menu-item-active-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:var(--ngx-editor-menu-item-active-bg-color)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:var(--ngx-editor-menu-item-hover-bg-color)}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--DropdownMenu{top:unset;bottom:calc(var(--ngx-editor-menubar-height) + 2px)}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--Text:after{transform:rotate(180deg)}.NgxEditor__MenuBar--Reverse .NgxEditor__Popup{top:unset;bottom:calc(var(--ngx-editor-menubar-height) + 2px)}.NgxEditor__Popup{position:absolute;top:calc(var(--ngx-editor-menubar-height) + 2px);box-shadow:var(--ngx-editor-popup-shadow);border-radius:var(--ngx-editor-popup-border-radius);background-color:var(--ngx-editor-popup-bg-color);z-index:10;min-width:192px;padding:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid var(--ngx-editor-seperator-color);margin:0 5px}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:var(--ngx-editor-error-color)}\n"] }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ElementRef }], propDecorators: { ngxEditor: [{
                type: ViewChild,
                args: ['ngxEditor', { static: true }]
            }], editor: [{
                type: Input
            }], outputFormat: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], focusOut: [{
                type: Output
            }], focusIn: [{
                type: Output
            }] } });

class MenuService {
    constructor() {
        this.customMenuRefChange = new Subject();
    }
    setCustomMenuRef(c) {
        this.customMenuRefChange.next(c);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class Mark {
    constructor(name) {
        this.name = name;
    }
    apply() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return applyMark(type)(state, dispatch);
        };
    }
    toggle() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return toggleMark(type)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    canExecute(state) {
        return this.toggle()(state);
    }
}

class Blockqote {
    toggle() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.nodes['blockquote'];
            if (!type) {
                return false;
            }
            if (this.isActive(state)) {
                return lift(state, dispatch);
            }
            return wrapIn(type)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.nodes['blockquote'];
        if (!type) {
            return false;
        }
        return isNodeActive(state, type);
    }
    canExecute(state) {
        return this.toggle()(state);
    }
}

class HorizontalRule {
    insert() {
        return (state, dispatch) => {
            const { schema, tr } = state;
            const type = schema.nodes['horizontal_rule'];
            if (!type) {
                return false;
            }
            dispatch(tr.replaceSelectionWith(type.create()).scrollIntoView());
            return true;
        };
    }
    canExecute(state) {
        return canInsert(state, state.schema.nodes['horizontal_rule']);
    }
}

class ListItem {
    constructor(isBulletList = false) {
        this.isBulletList = false;
        this.isBulletList = isBulletList;
    }
    getType(schema) {
        return this.isBulletList ? schema.nodes['bullet_list'] : schema.nodes['ordered_list'];
    }
    toggle() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = this.getType(schema);
            if (!type) {
                return false;
            }
            if (this.isActive(state)) {
                return liftListItem(schema.nodes['list_item'])(state, dispatch);
            }
            return wrapInList(type)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = this.getType(schema);
        if (!type) {
            return false;
        }
        return isNodeActive(state, type);
    }
    canExecute(state) {
        return this.toggle()(state);
    }
}

class Heading {
    constructor(level) {
        this.level = level;
    }
    apply() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.nodes['heading'];
            if (!type) {
                return false;
            }
            return setBlockType(type)(state, dispatch);
        };
    }
    toggle() {
        return (state, dispatch) => {
            const { schema, selection, doc } = state;
            const type = schema.nodes['heading'];
            if (!type) {
                return false;
            }
            const nodePos = selection.$from.before(1);
            const node = doc.nodeAt(nodePos);
            const attrs = node?.attrs ?? {};
            if (this.isActive(state)) {
                return setBlockType(schema.nodes['paragraph'], attrs)(state, dispatch);
            }
            return setBlockType(type, { ...attrs, level: this.level })(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const nodesInSelection = getSelectionNodes(state);
        const type = schema.nodes['heading'];
        if (!type) {
            return false;
        }
        const supportedNodes = [
            type,
            schema.nodes['text'],
            schema.nodes['blockquote'],
        ];
        // heading is a text node
        // don't mark as active when it has more nodes
        const nodes = nodesInSelection.filter((node) => {
            return supportedNodes.includes(node.type);
        });
        const acitveNode = nodes.find((node) => {
            return node.attrs['level'] === this.level;
        });
        return Boolean(acitveNode);
    }
    canExecute(state) {
        return this.toggle()(state);
    }
}

class TextAlign {
    constructor(align) {
        this.align = align;
    }
    toggle() {
        return (state, dispatch) => {
            const { doc, selection, tr, schema } = state;
            const { from, to } = selection;
            let applicable = false;
            doc.nodesBetween(from, to, (node, pos) => {
                const nodeType = node.type;
                if ([schema.nodes['paragraph'], schema.nodes['heading']].includes(nodeType)) {
                    applicable = true;
                    const align = node.attrs['align'] === this.align ? null : this.align;
                    tr.setNodeMarkup(pos, nodeType, { ...node.attrs, align });
                }
                return true;
            });
            if (!applicable) {
                return false;
            }
            if (tr.docChanged) {
                dispatch?.(tr);
            }
            return true;
        };
    }
    isActive(state) {
        const nodes = getSelectionNodes(state);
        const active = nodes.find((node) => {
            return node.attrs['align'] === this.align;
        });
        return Boolean(active);
    }
    canExecute(state) {
        return this.toggle()(state);
    }
}

const defaultOptions = {
    strict: true,
};
let Link$1 = class Link {
    update(attrs) {
        return (state, dispatch) => {
            const { schema, selection } = state;
            const type = schema.marks['link'];
            if (!type) {
                return false;
            }
            if (selection.empty) {
                return false;
            }
            return toggleMark(type, attrs)(state, dispatch);
        };
    }
    insert(text, attrs) {
        return (state, dispatch) => {
            const { schema, tr } = state;
            const type = schema.marks['link'];
            if (!type) {
                return false;
            }
            const linkAttrs = {
                href: attrs.href,
                title: attrs.title ?? text,
                target: attrs.target ?? '_blank',
            };
            const node = schema.text(text, [schema.marks['link'].create(linkAttrs)]);
            tr.replaceSelectionWith(node, false)
                .scrollIntoView();
            if (tr.docChanged) {
                dispatch?.(tr);
                return true;
            }
            return false;
        };
    }
    isActive(state, options = defaultOptions) {
        if (options.strict) {
            return true;
        }
        const { schema } = state;
        const type = schema.marks['link'];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    remove(state, dispatch) {
        return removeLink()(state, dispatch);
    }
    canExecute(state) {
        const testAttrs = {
            href: '',
        };
        return this.insert('Exec', testAttrs)(state) || this.update(testAttrs)(state);
    }
};

let Image$1 = class Image {
    insert(src, attrs) {
        return (state, dispatch) => {
            const { schema, tr, selection } = state;
            const type = schema.nodes['image'];
            if (!type) {
                return false;
            }
            const imageAttrs = {
                width: null,
                src,
                ...attrs,
            };
            if (!imageAttrs.width && selection instanceof NodeSelection && selection.node.type === type) {
                imageAttrs.width = selection.node.attrs['width'];
            }
            tr.replaceSelectionWith(type.createAndFill(imageAttrs));
            const resolvedPos = tr.doc.resolve(tr.selection.anchor - tr.selection.$anchor.nodeBefore.nodeSize);
            tr
                .setSelection(new NodeSelection(resolvedPos))
                .scrollIntoView();
            if (tr.docChanged) {
                dispatch?.(tr);
                return true;
            }
            return false;
        };
    }
    isActive(state) {
        const { selection } = state;
        if (selection instanceof NodeSelection) {
            return selection.node.type.name === 'image';
        }
        return false;
    }
};

let TextColor$1 = class TextColor {
    constructor(name, attrName = 'color') {
        this.name = name;
        this.attrName = attrName;
    }
    apply(attrs) {
        return (state, dispatch) => {
            const { schema, selection, doc } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            const { from, to, empty } = selection;
            if (!empty && (from + 1 === to)) {
                const node = doc.nodeAt(from);
                if (node?.isAtom && !node.isText && node.isLeaf) {
                    // An atomic node (e.g. Image) is selected.
                    return false;
                }
            }
            return applyMark(type, attrs)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    getActiveColors(state) {
        if (!this.isActive(state)) {
            return [];
        }
        const { schema } = state;
        const marks = getSelectionMarks(state);
        const colors = marks
            .filter((mark) => mark.type === schema.marks[this.name])
            .map((mark) => {
            return mark.attrs[this.attrName];
        })
            .filter(Boolean);
        return colors;
    }
    remove() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return removeMark(type)(state, dispatch);
        };
    }
    canExecute(state) {
        const attrs = this.name === 'text_color' ? { color: '' } : { backgroundColor: '' };
        return this.apply(attrs)(state);
    }
};

const SAFE_MARKS = ['link'];
class FormatClear {
    insert() {
        return (state, dispatch) => {
            const { tr } = state;
            const { ranges, empty } = tr.selection;
            if (empty) {
                return true;
            }
            Object.entries(state.schema.marks).forEach(([markType, mark]) => {
                if (SAFE_MARKS.includes(markType)) {
                    return;
                }
                ranges.forEach((range) => {
                    tr.removeMark(range.$from.pos, range.$to.pos, mark);
                });
            });
            dispatch(tr);
            return true;
        };
    }
    canExecute() {
        return true;
    }
}

const indentNodeTypes = ['paragraph', 'heading', 'blockquote'];
const minIndent = 0;
const maxIndent = 10;
const udpateIndentLevel = (tr, pos, method) => {
    const node = tr.doc.nodeAt(pos);
    if (!node) {
        return false;
    }
    const nodeIndent = node.attrs['indent'] ?? 0;
    const newIndent = clamp(nodeIndent + (method === 'increase' ? 1 : -1), minIndent, maxIndent);
    if (newIndent === nodeIndent || newIndent < minIndent || newIndent > maxIndent) {
        return false;
    }
    const attrs = {
        ...node.attrs,
        indent: newIndent,
    };
    tr.setNodeMarkup(pos, node.type, attrs);
    return true;
};
class Indent {
    constructor(method) {
        this.method = 'increase';
        this.method = method;
    }
    insert() {
        return (state, dispatch) => {
            const { tr, doc } = state;
            const { from, to } = tr.selection;
            let applicable = false;
            doc.nodesBetween(from, to, (node, pos) => {
                const nodeType = node.type;
                if (indentNodeTypes.includes(nodeType.name)) {
                    applicable = udpateIndentLevel(tr, pos, this.method);
                    return false;
                }
                else if (node.type.name.includes('list')) {
                    return false;
                }
                return true;
            });
            if (!applicable) {
                return false;
            }
            if (tr.docChanged) {
                dispatch?.(tr);
            }
            return true;
        };
    }
    canExecute(state) {
        return this.insert()(state);
    }
}

class History {
    constructor(mode) {
        this.mode = 'undo';
        this.mode = mode;
    }
    insert() {
        return (state, dispatch) => {
            if (this.mode === 'undo') {
                return undo$1(state, dispatch);
            }
            return redo$1(state, dispatch);
        };
    }
    canExecute(state) {
        return this.insert()(state);
    }
}

const STRONG = new Mark('strong');
const EM = new Mark('em');
const CODE = new Mark('code');
const UNDERLINE = new Mark('u');
const STRIKE = new Mark('s');
const BLOCKQUOTE = new Blockqote();
const HORIZONTAL_RULE = new HorizontalRule();
const FORMAT_CLEAR = new FormatClear();
const UL = new ListItem(true);
const OL = new ListItem(false);
const H1 = new Heading(1);
const H2 = new Heading(2);
const H3 = new Heading(3);
const H4 = new Heading(4);
const H5 = new Heading(5);
const H6 = new Heading(6);
const ALIGN_LEFT = new TextAlign('left');
const ALIGN_CENTER = new TextAlign('center');
const ALIGN_RIGHT = new TextAlign('right');
const ALIGN_JUSTIFY = new TextAlign('justify');
const LINK = new Link$1();
const IMAGE = new Image$1();
const TEXT_COLOR = new TextColor$1('text_color', 'color');
const TEXT_BACKGROUND_COLOR = new TextColor$1('text_background_color', 'backgroundColor');
const INDENT = new Indent('increase');
const OUTDENT = new Indent('decrease');
const SUPERSCRIPT = new Mark('sup');
const SUBSCRIPT = new Mark('sub');
const UNDO = new History('undo');
const REDO = new History('redo');

const ToggleCommands = {
    bold: STRONG,
    italic: EM,
    code: CODE,
    underline: UNDERLINE,
    strike: STRIKE,
    blockquote: BLOCKQUOTE,
    bullet_list: UL,
    ordered_list: OL,
    h1: H1,
    h2: H2,
    h3: H3,
    h4: H4,
    h5: H5,
    h6: H6,
    align_left: ALIGN_LEFT,
    align_center: ALIGN_CENTER,
    align_right: ALIGN_RIGHT,
    align_justify: ALIGN_JUSTIFY,
    superscript: SUPERSCRIPT,
    subscript: SUBSCRIPT,
};
const InsertCommands = {
    horizontal_rule: HORIZONTAL_RULE,
    format_clear: FORMAT_CLEAR,
    indent: INDENT,
    outdent: OUTDENT,
    undo: UNDO,
    redo: REDO,
};
const Link = LINK;
const Image = IMAGE;
const TextColor = TEXT_COLOR;
const TextBackgroundColor = TEXT_BACKGROUND_COLOR;

const defaults = {
    // menu
    bold: 'Bold',
    italic: 'Italic',
    code: 'Code',
    underline: 'Underline',
    strike: 'Strike',
    blockquote: 'Blockquote',
    bullet_list: 'Bullet List',
    ordered_list: 'Ordered List',
    heading: 'Heading',
    h1: 'Header 1',
    h2: 'Header 2',
    h3: 'Header 3',
    h4: 'Header 4',
    h5: 'Header 5',
    h6: 'Header 6',
    align_left: 'Left Align',
    align_center: 'Center Align',
    align_right: 'Right Align',
    align_justify: 'Justify',
    text_color: 'Text Color',
    background_color: 'Background Color',
    horizontal_rule: 'Horizontal rule',
    format_clear: 'Clear Formatting',
    insertLink: 'Insert Link',
    removeLink: 'Remove Link',
    insertImage: 'Insert Image',
    indent: 'Increase Indent',
    outdent: 'Decrease Indent',
    superscript: 'Superscript',
    subscript: 'Subscript',
    undo: 'Undo',
    redo: 'Redo',
    // pupups, forms, others...
    url: 'URL',
    text: 'Text',
    openInNewTab: 'Open in new tab',
    insert: 'Insert',
    altText: 'Alt Text',
    title: 'Title',
    remove: 'Remove',
    enterValidUrl: 'Please enter a valid URL',
};
class Locals {
    constructor(newLocals = {}) {
        this.locals = defaults;
        this.get = (key) => {
            const value = this.locals[key];
            if (value) {
                return isObservable(value) ? value : of(value);
            }
            return of('');
        };
        this.locals = { ...defaults, ...newLocals };
    }
}

var bold = `
  <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />
`;

var italic = `
  <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />
`;

var code = `
<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
`;

var underline = `
<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>
`;

var strike = `
<path d="M6.85,7.08C6.85,4.37,9.45,3,12.24,3c1.64,0,3,0.49,3.9,1.28c0.77,0.65,1.46,1.73,1.46,3.24h-3.01 c0-0.31-0.05-0.59-0.15-0.85c-0.29-0.86-1.2-1.28-2.25-1.28c-1.86,0-2.34,1.02-2.34,1.7c0,0.48,0.25,0.88,0.74,1.21 C10.97,8.55,11.36,8.78,12,9H7.39C7.18,8.66,6.85,8.11,6.85,7.08z M21,12v-2H3v2h9.62c1.15,0.45,1.96,0.75,1.96,1.97 c0,1-0.81,1.67-2.28,1.67c-1.54,0-2.93-0.54-2.93-2.51H6.4c0,0.55,0.08,1.13,0.24,1.58c0.81,2.29,3.29,3.3,5.67,3.3 c2.27,0,5.3-0.89,5.3-4.05c0-0.3-0.01-1.16-0.48-1.94H21V12z"/>
`;

var orderedList = `
<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>
`;

var bulletList = `
<path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/>
`;

var quote = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>
`;

var link = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
`;

var unlink = `
<path d="M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z"/>
`;

var image = `
<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
`;

var alignLeft = `
<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>
`;

var alignCenter = `
<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>
`;

var alignRight = `
<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>
`;

var alignJustify = `
<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>
`;

var textColor = `
<path d="M2,20h20v4H2V20z M5.49,17h2.42l1.27-3.58h5.65L16.09,17h2.42L13.25,3h-2.5L5.49,17z M9.91,11.39l2.03-5.79h0.12l2.03,5.79 H9.91z"/>
`;

var colorFill = `
<path d="M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z"/>
`;

var horizontalRule = `
  <g>
    <rect fill="none" fill-rule="evenodd" height="24" width="24"/>
    <rect fill-rule="evenodd" height="2" width="16" x="4" y="11"/>
  </g>
`;

var formatClear = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M3.27 5L2 6.27l6.97 6.97L6.5 19h3l1.57-3.66L16.73 21 18 19.73 3.55 5.27 3.27 5zM6 5v.18L8.82 8h2.4l-.72 1.68 2.1 2.1L14.21 8H20V5H6z"/>
`;

var indent = '<path d="M0 0h24v24H0V0z" fill="none"/><path d="M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"/>';

var outdent = '<path d="M0 0h24v24H0V0z" fill="none"/><path d="M11 17h10v-2H11v2zm-8-5l4 4V8l-4 4zm0 9h18v-2H3v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"/>';

var superscript = '<g><rect fill="none" height="20" width="20"/><path d="M17,6l-1,0v1h2v1l-3,0V6c0-0.55,0.45-1,1-1l1,0l0-1h-2V3l2,0c0.55,0,1,0.45,1,1v1C18,5.55,17.55,6,17,6z M5.63,16h1.9 l2.43-3.87h0.08L12.47,16h1.9l-3.32-5.2l3.1-4.8h-1.91l-2.19,3.56H9.96L7.75,6h-1.9l3.09,4.8L5.63,16z"/></g>';

var subscript = '<g><rect fill="none" height="20" width="20"/><path d="M17,15l-1,0v1h2v1h-3v-2c0-0.55,0.45-1,1-1l1,0l0-1h-2v-1l2,0c0.55,0,1,0.45,1,1v1C18,14.55,17.55,15,17,15z M5.63,14h1.9 l2.43-3.87h0.08L12.47,14h1.9l-3.32-5.2l3.1-4.8h-1.91l-2.19,3.56H9.96L7.75,4h-1.9l3.09,4.8L5.63,14z"/></g>';

var undo = '<path d="M0 0h24v24H0V0z" fill="none"/><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>';

var redo = '<path d="M0 0h24v24H0V0z" fill="none"/><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/>';

/* eslint-disable @typescript-eslint/naming-convention */
// Icons source: https://material.io/
const DEFAULT_ICON_HEIGHT = 20;
const DEFAULT_ICON_WIDTH = 20;
const DEFAULT_ICON_FILL = 'currentColor';
const icons = {
    bold,
    italic,
    code,
    underline,
    strike,
    ordered_list: orderedList,
    bullet_list: bulletList,
    blockquote: quote,
    link,
    unlink,
    image,
    align_left: alignLeft,
    align_center: alignCenter,
    align_right: alignRight,
    align_justify: alignJustify,
    text_color: textColor,
    color_fill: colorFill,
    horizontal_rule: horizontalRule,
    format_clear: formatClear,
    indent,
    outdent,
    superscript,
    subscript,
    undo,
    redo,
    path: '<path></path>',
};
class Icon {
    static get(name, fill = DEFAULT_ICON_FILL) {
        const fullPath = icons[name];
        if (fullPath && (fullPath.includes('<path') || fullPath.includes('<g'))) {
            return `
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill=${fill}
          height=${DEFAULT_ICON_HEIGHT}
          width=${DEFAULT_ICON_WIDTH}
        >
          ${fullPath}
        </svg>
      `;
        }
        return fullPath;
    }
}

class NgxEditorServiceConfig {
    constructor() {
        this.locals = {};
        this.icons = {};
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorServiceConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorServiceConfig, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorServiceConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class NgxEditorService {
    constructor(config) {
        this.config = config;
    }
    get locals() {
        return new Locals(this.config.locals);
    }
    getIcon(icon) {
        return this.config.icons[icon] ? this.config.icons[icon] : Icon.get(icon);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorService, deps: [{ token: NgxEditorServiceConfig, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: NgxEditorServiceConfig, decorators: [{
                    type: Optional
                }] }] });
const provideMyServiceOptions = (config) => {
    return {
        locals: config.locals ?? {},
        icons: config.icons ?? {},
    };
};

class SanitizeHtmlPipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(value) {
        if (isTrustedHtml(value)) {
            return value;
        }
        return this.sanitizer.bypassSecurityTrustHtml(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: SanitizeHtmlPipe, deps: [{ token: i1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: SanitizeHtmlPipe, name: "sanitizeHtml" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: SanitizeHtmlPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'sanitizeHtml',
                }]
        }], ctorParameters: () => [{ type: i1.DomSanitizer }] });

class ToggleCommandComponent {
    get name() {
        return this.toolbarItem;
    }
    constructor(ngxeService, menuService) {
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.isActive = false;
        this.disabled = false;
        this.update = (view) => {
            const { state } = view;
            const command = ToggleCommands[this.name];
            this.isActive = command.isActive(state);
            this.disabled = !command.canExecute(state);
        };
    }
    toggle() {
        const { state, dispatch } = this.editorView;
        const command = ToggleCommands[this.name];
        command.toggle()(state, dispatch);
    }
    onMouseClick(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.toggle();
    }
    onKeydown() {
        this.toggle();
    }
    getTitle(name) {
        return this.ngxeService.locals.get(name);
    }
    ngOnInit() {
        this.html = this.ngxeService.getIcon(this.name);
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ToggleCommandComponent, deps: [{ token: NgxEditorService }, { token: MenuService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: ToggleCommandComponent, selector: "ngx-toggle-command", inputs: { toolbarItem: "toolbarItem" }, ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive\"\n  [class.NgxEditor--Disabled]=\"disabled\"\n  [disabled]=\"disabled\"\n  [innerHTML]=\"html | sanitizeHtml\"\n  (mousedown)=\"onMouseClick($event)\"\n  (keydown.enter)=\"onKeydown()\"\n  (keydown.space)=\"onKeydown()\"\n  [title]=\"getTitle(name) | async\"\n  [ariaLabel]=\"getTitle(name) | async\"\n></button>\n", styles: [""], dependencies: [{ kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SanitizeHtmlPipe, name: "sanitizeHtml" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ToggleCommandComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-toggle-command', template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive\"\n  [class.NgxEditor--Disabled]=\"disabled\"\n  [disabled]=\"disabled\"\n  [innerHTML]=\"html | sanitizeHtml\"\n  (mousedown)=\"onMouseClick($event)\"\n  (keydown.enter)=\"onKeydown()\"\n  (keydown.space)=\"onKeydown()\"\n  [title]=\"getTitle(name) | async\"\n  [ariaLabel]=\"getTitle(name) | async\"\n></button>\n" }]
        }], ctorParameters: () => [{ type: NgxEditorService }, { type: MenuService }], propDecorators: { toolbarItem: [{
                type: Input
            }] } });

class InsertCommandComponent {
    get name() {
        return this.toolbarItem;
    }
    constructor(ngxeService, menuService) {
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.disabled = false;
        this.update = (view) => {
            const { state } = view;
            const command = InsertCommands[this.name];
            this.disabled = !command.canExecute(state);
        };
    }
    onMouseClick(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.insert();
    }
    onKeydown() {
        this.insert();
    }
    insert() {
        const { state, dispatch } = this.editorView;
        const command = InsertCommands[this.name];
        command.insert()(state, dispatch);
    }
    getTitle(name) {
        return this.ngxeService.locals.get(name);
    }
    ngOnInit() {
        this.html = this.ngxeService.getIcon(this.name);
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: InsertCommandComponent, deps: [{ token: NgxEditorService }, { token: MenuService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: InsertCommandComponent, selector: "ngx-insert-command", inputs: { toolbarItem: "toolbarItem" }, ngImport: i0, template: "<button\n  class=\"NgxEditor__MenuItem--Icon\"\n  [disabled]=\"disabled\"\n  [class.NgxEditor--Disabled]=\"disabled\"\n  [innerHTML]=\"html | sanitizeHtml\"\n  (mousedown)=\"onMouseClick($event)\"\n  (keydown.enter)=\"onKeydown()\"\n  (keydown.space)=\"onKeydown()\"\n  [title]=\"getTitle(name) | async\"\n  [ariaLabel]=\"getTitle(name) | async\"\n></button>\n", styles: [""], dependencies: [{ kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SanitizeHtmlPipe, name: "sanitizeHtml" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: InsertCommandComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-insert-command', template: "<button\n  class=\"NgxEditor__MenuItem--Icon\"\n  [disabled]=\"disabled\"\n  [class.NgxEditor--Disabled]=\"disabled\"\n  [innerHTML]=\"html | sanitizeHtml\"\n  (mousedown)=\"onMouseClick($event)\"\n  (keydown.enter)=\"onKeydown()\"\n  (keydown.space)=\"onKeydown()\"\n  [title]=\"getTitle(name) | async\"\n  [ariaLabel]=\"getTitle(name) | async\"\n></button>\n" }]
        }], ctorParameters: () => [{ type: NgxEditorService }, { type: MenuService }], propDecorators: { toolbarItem: [{
                type: Input
            }] } });

const DEFAULT_LINK_OPTIONS = {
    showOpenInNewTab: true,
};
class LinkComponent {
    constructor(el, ngxeService, menuService) {
        this.el = el;
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.options = DEFAULT_LINK_OPTIONS;
        this.showPopup = false;
        this.isActive = false;
        this.canExecute = true;
        this.componentId = uniq();
        this.setText = () => {
            const { state: { selection, doc } } = this.editorView;
            const { empty, from, to } = selection;
            const selectedText = !empty ? doc.textBetween(from, to) : '';
            if (selectedText) {
                this.text.patchValue(selectedText);
                this.text.disable();
            }
        };
        this.update = (view) => {
            const { state } = view;
            this.isActive = Link.isActive(state, { strict: false });
            this.canExecute = Link.canExecute(state);
        };
    }
    get icon() {
        return this.ngxeService.getIcon(this.isActive ? 'unlink' : 'link');
    }
    get title() {
        return this.ngxeService.locals.get(this.isActive ? 'removeLink' : 'insertLink');
    }
    get href() {
        return this.form.get('href');
    }
    get text() {
        return this.form.get('text');
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hidePopup();
        }
    }
    getId(name) {
        return `${name}-${this.componentId}`;
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    hidePopup() {
        this.showPopup = false;
        this.form.reset({
            href: '',
            text: '',
            openInNewTab: true,
        });
        this.text.enable();
    }
    togglePopup() {
        const { state, dispatch } = this.editorView;
        if (this.isActive) {
            Link.remove(state, dispatch);
            return;
        }
        this.showPopup = !this.showPopup;
        if (this.showPopup) {
            this.setText();
        }
    }
    onTogglePopupMouseClick(e) {
        if (e.button !== 0) {
            return;
        }
        this.togglePopup();
    }
    onTogglePopupKeydown() {
        this.togglePopup();
    }
    insertLink(e) {
        e.preventDefault();
        const { text, href, openInNewTab } = this.form.getRawValue();
        const { dispatch, state } = this.editorView;
        const { selection } = state;
        let target;
        if (this.options.showOpenInNewTab) {
            target = openInNewTab ? '_blank' : '_self';
        }
        const attrs = {
            title: href,
            href,
            target,
        };
        if (selection.empty) {
            Link.insert(text, attrs)(state, dispatch);
            this.editorView.focus();
        }
        else {
            Link.update(attrs)(state, dispatch);
        }
        this.hidePopup();
    }
    ngOnInit() {
        this.editorView = this.menuService.editor.view;
        this.form = new FormGroup({
            href: new FormControl('', [
                Validators$1.required,
                Validators$1.pattern(this.menuService.editor.linkValidationPattern),
            ]),
            text: new FormControl('', [Validators$1.required]),
            openInNewTab: new FormControl(true),
        });
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: LinkComponent, deps: [{ token: i0.ElementRef }, { token: NgxEditorService }, { token: MenuService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.8", type: LinkComponent, selector: "ngx-link", inputs: { options: ["options", "options", (value) => ({ ...DEFAULT_LINK_OPTIONS, ...value })] }, host: { listeners: { "document:mousedown": "onDocumentClick($event)" } }, ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [class.NgxEditor--Disabled]=\"!canExecute\"\n  [disabled]=\"!canExecute\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"title | async\"\n  [ariaLabel]=\"title | async\"\n  aria-haspopup=\"dialog\"\n  [ariaExpanded]=\"showPopup\"\n></button>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('link-popup-url')\">{{ getLabel('url') | async }}</label>\n        <input type=\"href\" [id]=\"getId('link-popup-url')\" formControlName=\"href\" autocomplete=\"off\" />\n        <div *ngIf=\"href.touched && href.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ href.errors?.['pattern'] && getLabel('enterValidUrl') | async }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('link-popup-label')\">{{\n          getLabel('text') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('link-popup-label')\" formControlName=\"text\" autocomplete=\"off\" />\n        <div *ngIf=\"text.touched && text.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ text.errors?.['required'] && 'This is required' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\" *ngIf=\"this.options.showOpenInNewTab\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label>\n          <input type=\"checkbox\" formControlName=\"openInNewTab\" />\n          {{ getLabel('openInNewTab') | async }}\n        </label>\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid\">{{ getLabel('insert') | async }}</button>\n  </form>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SanitizeHtmlPipe, name: "sanitizeHtml" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: LinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-link', template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [class.NgxEditor--Disabled]=\"!canExecute\"\n  [disabled]=\"!canExecute\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"title | async\"\n  [ariaLabel]=\"title | async\"\n  aria-haspopup=\"dialog\"\n  [ariaExpanded]=\"showPopup\"\n></button>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('link-popup-url')\">{{ getLabel('url') | async }}</label>\n        <input type=\"href\" [id]=\"getId('link-popup-url')\" formControlName=\"href\" autocomplete=\"off\" />\n        <div *ngIf=\"href.touched && href.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ href.errors?.['pattern'] && getLabel('enterValidUrl') | async }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('link-popup-label')\">{{\n          getLabel('text') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('link-popup-label')\" formControlName=\"text\" autocomplete=\"off\" />\n        <div *ngIf=\"text.touched && text.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ text.errors?.['required'] && 'This is required' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\" *ngIf=\"this.options.showOpenInNewTab\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label>\n          <input type=\"checkbox\" formControlName=\"openInNewTab\" />\n          {{ getLabel('openInNewTab') | async }}\n        </label>\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid\">{{ getLabel('insert') | async }}</button>\n  </form>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: NgxEditorService }, { type: MenuService }], propDecorators: { options: [{
                type: Input,
                args: [{
                        transform: (value) => ({ ...DEFAULT_LINK_OPTIONS, ...value }),
                    }]
            }], onDocumentClick: [{
                type: HostListener,
                args: ['document:mousedown', ['$event']]
            }] } });

class DropdownComponent {
    constructor(ngxeService, menuService, el) {
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.el = el;
        this.isDropdownOpen = false;
        this.disabledItems = [];
        this.update = (view) => {
            const { state } = view;
            this.disabledItems = [];
            const activeItems = [];
            this.items.forEach((item) => {
                const command = ToggleCommands[item];
                const isActive = command.isActive(state);
                if (isActive) {
                    activeItems.push(item);
                }
                if (!command.canExecute(state)) {
                    this.disabledItems.push(item);
                }
            });
            if (activeItems.length === 1) {
                [this.activeItem] = activeItems;
            }
            else {
                this.activeItem = null;
            }
        };
    }
    get isSelected() {
        return Boolean(this.activeItem || this.isDropdownOpen);
    }
    get isDropdownDisabled() {
        return this.disabledItems.length === this.items.length;
    }
    onDocumentClick(target) {
        if (!this.el.nativeElement.contains(target) && this.isDropdownOpen) {
            this.isDropdownOpen = false;
        }
    }
    getName(key) {
        return this.ngxeService.locals.get(key);
    }
    getIsDropdownActive(item) {
        return this.activeItem === item;
    }
    toggleDropdown() {
        this.isDropdownOpen = !this.isDropdownOpen;
    }
    onToggleDropdownMouseClick(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.toggleDropdown();
    }
    onToggleDropdownKeydown() {
        this.toggleDropdown();
    }
    trackByIndex(index) {
        return index;
    }
    selectItem(item) {
        const command = ToggleCommands[item];
        const { state, dispatch } = this.editorView;
        command.toggle()(state, dispatch);
        this.isDropdownOpen = false;
    }
    onDropdownItemMouseClick(e, item) {
        e.preventDefault();
        // consider only left click
        if (e.button !== 0) {
            return;
        }
        this.selectItem(item);
    }
    onDropdownItemKeydown(event, item) {
        const e = event;
        e.preventDefault();
        this.selectItem(item);
    }
    ngOnInit() {
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DropdownComponent, deps: [{ token: NgxEditorService }, { token: MenuService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: DropdownComponent, selector: "ngx-dropdown", inputs: { group: "group", items: "items" }, host: { listeners: { "document:mousedown": "onDocumentClick($event.target)" } }, ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"NgxEditor__Dropdown--Text\"\n  [class.NgxEditor__Dropdown--Selected]=\"isSelected\"\n  [disabled]=\"isDropdownDisabled\"\n  [class.NgxEditor--Disabled]=\"isDropdownDisabled\"\n  (mousedown)=\"onToggleDropdownMouseClick($event)\"\n  (keydown.enter)=\"onToggleDropdownKeydown()\"\n  (keydown.space)=\"onToggleDropdownKeydown()\"\n  [ariaLabel]=\"getName(activeItem || group) | async\"\n  aria-haspopup=\"listbox\"\n  [ariaExpanded]=\"isDropdownOpen\"\n>\n  {{ getName(activeItem || group) | async }}\n</button>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\" role=\"listbox\">\n  <button\n    type=\"button\"\n    class=\"NgxEditor__Dropdown--Item\"\n    *ngFor=\"let item of items; trackBy: trackByIndex\"\n    (mousedown)=\"onDropdownItemMouseClick($event, item)\"\n    (keydown.enter)=\"onDropdownItemKeydown($event, item)\"\n    (keydown.space)=\"onDropdownItemKeydown($event, item)\"\n    [ngClass]=\"{\n      'NgxEditor__Dropdown--Active': item === activeItem,\n      'NgxEditor--Disabled': disabledItems.includes(item)\n    }\"\n    [ariaLabel]=\"getName(item) | async\"\n    role=\"option\"\n    [attr.aria-selected]=\"item === activeItem\"\n  >\n    {{ getName(item) | async }}\n  </button>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: DropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-dropdown', template: "<button\n  type=\"button\"\n  class=\"NgxEditor__Dropdown--Text\"\n  [class.NgxEditor__Dropdown--Selected]=\"isSelected\"\n  [disabled]=\"isDropdownDisabled\"\n  [class.NgxEditor--Disabled]=\"isDropdownDisabled\"\n  (mousedown)=\"onToggleDropdownMouseClick($event)\"\n  (keydown.enter)=\"onToggleDropdownKeydown()\"\n  (keydown.space)=\"onToggleDropdownKeydown()\"\n  [ariaLabel]=\"getName(activeItem || group) | async\"\n  aria-haspopup=\"listbox\"\n  [ariaExpanded]=\"isDropdownOpen\"\n>\n  {{ getName(activeItem || group) | async }}\n</button>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\" role=\"listbox\">\n  <button\n    type=\"button\"\n    class=\"NgxEditor__Dropdown--Item\"\n    *ngFor=\"let item of items; trackBy: trackByIndex\"\n    (mousedown)=\"onDropdownItemMouseClick($event, item)\"\n    (keydown.enter)=\"onDropdownItemKeydown($event, item)\"\n    (keydown.space)=\"onDropdownItemKeydown($event, item)\"\n    [ngClass]=\"{\n      'NgxEditor__Dropdown--Active': item === activeItem,\n      'NgxEditor--Disabled': disabledItems.includes(item)\n    }\"\n    [ariaLabel]=\"getName(item) | async\"\n    role=\"option\"\n    [attr.aria-selected]=\"item === activeItem\"\n  >\n    {{ getName(item) | async }}\n  </button>\n</div>\n" }]
        }], ctorParameters: () => [{ type: NgxEditorService }, { type: MenuService }, { type: i0.ElementRef }], propDecorators: { group: [{
                type: Input
            }], items: [{
                type: Input
            }], onDocumentClick: [{
                type: HostListener,
                args: ['document:mousedown', ['$event.target']]
            }] } });

class ImageComponent {
    constructor(el, ngxeService, menuService) {
        this.el = el;
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.showPopup = false;
        this.isActive = false;
        this.componentId = uniq();
        this.form = new FormGroup({
            src: new FormControl('', [
                Validators$1.required,
                Validators$1.pattern('(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/??([^#\n\r]*)?#?([^\n\r]*)'),
            ]),
            alt: new FormControl(''),
            title: new FormControl(''),
        });
        this.update = (view) => {
            const { state } = view;
            this.isActive = Image.isActive(state);
        };
    }
    get icon() {
        return this.ngxeService.getIcon('image');
    }
    get src() {
        return this.form.get('src');
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hideForm();
        }
    }
    getId(name) {
        return `${name}-${this.componentId}`;
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    hideForm() {
        this.showPopup = false;
        this.form.reset({
            src: '',
            alt: '',
            title: '',
        });
    }
    togglePopup() {
        this.showPopup = !this.showPopup;
        if (this.showPopup) {
            this.fillForm();
        }
    }
    onTogglePopupMouseClick(e) {
        if (e.button !== 0) {
            return;
        }
        this.togglePopup();
    }
    onTogglePopupKeydown() {
        this.togglePopup();
    }
    fillForm() {
        const { state } = this.editorView;
        const { selection } = state;
        if (selection instanceof NodeSelection && this.isActive) {
            const { src, alt = '', title = '' } = selection.node.attrs;
            this.form.setValue({
                src,
                alt,
                title,
            });
        }
    }
    insertLink(e) {
        e.preventDefault();
        const { src, alt, title } = this.form.getRawValue();
        const { dispatch, state } = this.editorView;
        const attrs = {
            alt,
            title,
        };
        Image.insert(src, attrs)(state, dispatch);
        this.editorView.focus();
        this.hideForm();
    }
    ngOnInit() {
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ImageComponent, deps: [{ token: i0.ElementRef }, { token: NgxEditorService }, { token: MenuService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: ImageComponent, selector: "ngx-image", host: { listeners: { "document:mousedown": "onDocumentClick($event)" } }, ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"getLabel('insertImage') | async\"\n  [ariaLabel]=\"getLabel('insertImage') | async\"\n  aria-haspopup=\"dialog\"\n  [ariaExpanded]=\"showPopup\"\n></button>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-url')\">{{\n          getLabel('url') | async\n        }}</label>\n        <input type=\"href\" [id]=\"getId('image-popup-url')\" formControlName=\"src\" autocomplete=\"off\" />\n        <div *ngIf=\"src.touched && src.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ src.errors?.['pattern'] && getLabel('enterValidUrl') | async }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-label')\">{{\n          getLabel('altText') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('image-popup-label')\" formControlName=\"alt\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-title')\">{{\n          getLabel('title') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('image-popup-title')\" formControlName=\"title\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid || !form.dirty\">{{ getLabel('insert') | async }}</button>\n  </form>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SanitizeHtmlPipe, name: "sanitizeHtml" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ImageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-image', template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"getLabel('insertImage') | async\"\n  [ariaLabel]=\"getLabel('insertImage') | async\"\n  aria-haspopup=\"dialog\"\n  [ariaExpanded]=\"showPopup\"\n></button>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-url')\">{{\n          getLabel('url') | async\n        }}</label>\n        <input type=\"href\" [id]=\"getId('image-popup-url')\" formControlName=\"src\" autocomplete=\"off\" />\n        <div *ngIf=\"src.touched && src.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ src.errors?.['pattern'] && getLabel('enterValidUrl') | async }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-label')\">{{\n          getLabel('altText') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('image-popup-label')\" formControlName=\"alt\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\" [htmlFor]=\"getId('image-popup-title')\">{{\n          getLabel('title') | async\n        }}</label>\n        <input type=\"text\" [id]=\"getId('image-popup-title')\" formControlName=\"title\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid || !form.dirty\">{{ getLabel('insert') | async }}</button>\n  </form>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: NgxEditorService }, { type: MenuService }], propDecorators: { onDocumentClick: [{
                type: HostListener,
                args: ['document:mousedown', ['$event']]
            }] } });

class ColorPickerComponent {
    constructor(el, menuService, ngxeService) {
        this.el = el;
        this.menuService = menuService;
        this.ngxeService = ngxeService;
        this.showPopup = false;
        this.isActive = false;
        this.activeColors = [];
        this.canExecute = true;
        this.update = (view) => {
            const { state } = view;
            this.canExecute = this.command.canExecute(state);
            this.isActive = this.command.isActive(state);
            this.activeColors = [];
            if (this.isActive) {
                this.activeColors = this.command.getActiveColors(state);
            }
        };
    }
    get title() {
        return this.getLabel(this.type === 'text_color' ? 'text_color' : 'background_color');
    }
    get icon() {
        return this.ngxeService.getIcon(this.type === 'text_color' ? 'text_color' : 'color_fill');
    }
    get command() {
        return this.type === 'text_color' ? TextColor : TextBackgroundColor;
    }
    getContrastYIQ(hexcolor) {
        const color = hexcolor.replace('#', '');
        const r = parseInt(color.substring(0, 2), 16);
        const g = parseInt(color.substring(2, 4), 16);
        const b = parseInt(color.substring(4, 6), 16);
        const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
        return yiq >= 128 ? 'black' : 'white';
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hidePopup();
        }
    }
    hidePopup() {
        this.showPopup = false;
    }
    togglePopup() {
        this.showPopup = !this.showPopup;
    }
    onTogglePopupMouseClick(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.togglePopup();
    }
    onTogglePopupKeydown() {
        this.togglePopup();
    }
    remove() {
        const { state, dispatch } = this.editorView;
        this.command.remove()(state, dispatch);
        this.hidePopup();
    }
    onRemoveMouseClick(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        e.preventDefault();
        this.remove();
    }
    onRemoveKeydown() {
        this.remove();
    }
    trackByIndex(index) {
        return index;
    }
    selectColor(color) {
        const { state, dispatch } = this.editorView;
        if (this.type === 'text_color') {
            const attrs = { color };
            this.command.apply(attrs)(state, dispatch);
        }
        else {
            const attrs = { backgroundColor: color };
            this.command.apply(attrs)(state, dispatch);
        }
        if (!this.editorView.hasFocus()) {
            this.editorView.focus();
        }
        this.hidePopup();
    }
    onColorSelectMouseClick(e, color) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.selectColor(color);
    }
    onColorSelectKeydown(color) {
        this.selectColor(color);
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    ngOnInit() {
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ColorPickerComponent, deps: [{ token: i0.ElementRef }, { token: MenuService }, { token: NgxEditorService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: ColorPickerComponent, selector: "ngx-color-picker", inputs: { presets: "presets", type: "type" }, host: { listeners: { "document:mousedown": "onDocumentClick($event)" } }, ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [class.NgxEditor--Disabled]=\"!canExecute\"\n  [disabled]=\"!canExecute\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"title | async\"\n  [ariaLabel]=\"title | async\"\n></button>\n\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <div *ngFor=\"let colorGroup of presets; trackBy: trackByIndex\" class=\"NgxEditor__ColorContainer\">\n    <button\n      class=\"NgxEditor__Color\"\n      *ngFor=\"let color of colorGroup; trackBy: trackByIndex\"\n      [ngStyle]=\"{ backgroundColor: color, color: getContrastYIQ(color) }\"\n      [title]=\"color\"\n      (mousedown)=\"onColorSelectMouseClick($event, color)\"\n      (keydown.enter)=\"onColorSelectKeydown(color)\"\n      (keydown.space)=\"onColorSelectKeydown(color)\"\n      [ngClass]=\"{ 'NgxEditor__Color--Active': activeColors.includes(color) }\"\n    ></button>\n  </div>\n\n  <button\n    class=\"NgxEditor__MenuItem--Button\"\n    (mousedown)=\"onRemoveMouseClick($event)\"\n    (keydown.enter)=\"onRemoveKeydown()\"\n    (keydown.space)=\"onRemoveKeydown()\"\n    [disabled]=\"!isActive\"\n  >\n    {{ getLabel('remove') | async }}\n  </button>\n</div>\n", styles: ["@charset \"UTF-8\";.NgxEditor__Popup{width:230px}.NgxEditor__ColorContainer{display:flex;justify-content:space-between}.NgxEditor__ColorContainer+.NgxEditor__ColorContainer{margin-top:5px}.NgxEditor__Color{border:none;outline:none;border-radius:6px;width:24px;height:24px;flex-shrink:0}.NgxEditor__Color:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color);outline-offset:1px}.NgxEditor__Color--Active:after{content:\"\\2714\";font-size:90%}.NgxEditor__MenuItem--Button{margin-top:5px}\n"], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SanitizeHtmlPipe, name: "sanitizeHtml" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: ColorPickerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-color-picker', template: "<button\n  type=\"button\"\n  class=\"NgxEditor__MenuItem--Icon\"\n  [class.NgxEditor__MenuItem--Active]=\"isActive || showPopup\"\n  [class.NgxEditor--Disabled]=\"!canExecute\"\n  [disabled]=\"!canExecute\"\n  [innerHTML]=\"icon | sanitizeHtml\"\n  (mousedown)=\"onTogglePopupMouseClick($event)\"\n  (keydown.enter)=\"onTogglePopupKeydown()\"\n  (keydown.space)=\"onTogglePopupKeydown()\"\n  [title]=\"title | async\"\n  [ariaLabel]=\"title | async\"\n></button>\n\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <div *ngFor=\"let colorGroup of presets; trackBy: trackByIndex\" class=\"NgxEditor__ColorContainer\">\n    <button\n      class=\"NgxEditor__Color\"\n      *ngFor=\"let color of colorGroup; trackBy: trackByIndex\"\n      [ngStyle]=\"{ backgroundColor: color, color: getContrastYIQ(color) }\"\n      [title]=\"color\"\n      (mousedown)=\"onColorSelectMouseClick($event, color)\"\n      (keydown.enter)=\"onColorSelectKeydown(color)\"\n      (keydown.space)=\"onColorSelectKeydown(color)\"\n      [ngClass]=\"{ 'NgxEditor__Color--Active': activeColors.includes(color) }\"\n    ></button>\n  </div>\n\n  <button\n    class=\"NgxEditor__MenuItem--Button\"\n    (mousedown)=\"onRemoveMouseClick($event)\"\n    (keydown.enter)=\"onRemoveKeydown()\"\n    (keydown.space)=\"onRemoveKeydown()\"\n    [disabled]=\"!isActive\"\n  >\n    {{ getLabel('remove') | async }}\n  </button>\n</div>\n", styles: ["@charset \"UTF-8\";.NgxEditor__Popup{width:230px}.NgxEditor__ColorContainer{display:flex;justify-content:space-between}.NgxEditor__ColorContainer+.NgxEditor__ColorContainer{margin-top:5px}.NgxEditor__Color{border:none;outline:none;border-radius:6px;width:24px;height:24px;flex-shrink:0}.NgxEditor__Color:focus-visible{outline:1px solid var(--ngx-editor-focus-ring-color);outline-offset:1px}.NgxEditor__Color--Active:after{content:\"\\2714\";font-size:90%}.NgxEditor__MenuItem--Button{margin-top:5px}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: MenuService }, { type: NgxEditorService }], propDecorators: { presets: [{
                type: Input
            }], type: [{
                type: Input
            }], onDocumentClick: [{
                type: HostListener,
                args: ['document:mousedown', ['$event']]
            }] } });

const DEFAULT_TOOLBAR = [
    ['bold', 'italic'],
    ['code', 'blockquote'],
    ['underline', 'strike'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }],
    ['link', 'image'],
    ['text_color', 'background_color'],
    ['align_left', 'align_center', 'align_right', 'align_justify'],
    ['format_clear'],
];
const TOOLBAR_MINIMAL = [
    ['bold', 'italic'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }],
    ['link', 'image'],
    ['text_color', 'background_color'],
];
const TOOLBAR_FULL = [
    ['bold', 'italic'],
    ['code', 'blockquote'],
    ['underline', 'strike'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }],
    ['link', 'image'],
    ['text_color', 'background_color'],
    ['align_left', 'align_center', 'align_right', 'align_justify'],
    ['horizontal_rule', 'format_clear', 'indent', 'outdent'],
    ['superscript', 'subscript'],
    ['undo', 'redo'],
];
const DEFAULT_COLOR_PRESETS = [
    '#b60205',
    '#d93f0b',
    '#fbca04',
    '#0e8a16',
    '#006b75',
    '#1d76db',
    '#0052cc',
    '#5319e7',
    '#e99695',
    '#f9d0c4',
    '#fef2c0',
    '#c2e0c6',
    '#bfdadc',
    '#c5def5',
    '#bfd4f2',
    '#d4c5f9',
];
class MenuComponent {
    constructor(menuService) {
        this.menuService = menuService;
        this.toolbar = TOOLBAR_MINIMAL;
        this.colorPresets = DEFAULT_COLOR_PRESETS;
        this.disabled = false;
        this.customMenuRef = null;
        this.dropdownPlacement = 'bottom';
        this.toggleCommands = [
            'bold',
            'italic',
            'underline',
            'strike',
            'code',
            'blockquote',
            'ordered_list',
            'bullet_list',
            'align_left',
            'align_center',
            'align_right',
            'align_justify',
            'superscript',
            'subscript',
        ];
        this.insertCommands = [
            'horizontal_rule',
            'format_clear',
            'indent',
            'outdent',
            'undo',
            'redo',
        ];
        this.iconContainerClass = ['NgxEditor__MenuItem', 'NgxEditor__MenuItem--IconContainer'];
        this.dropdownContainerClass = ['NgxEditor__Dropdown'];
        this.seperatorClass = ['NgxEditor__Seperator'];
    }
    get presets() {
        const col = 8;
        const colors = [];
        this.colorPresets.forEach((color, index) => {
            const row = Math.floor(index / col);
            if (!colors[row]) {
                colors.push([]);
            }
            colors[row].push(color);
        });
        return colors;
    }
    trackByIndex(index) {
        return index;
    }
    isDropDown(item) {
        if (item?.heading) {
            return true;
        }
        return false;
    }
    getDropdownItems(item) {
        return item;
    }
    isLinkItem(item) {
        if (item === 'link') {
            return true;
        }
        // NOTE: it is not sufficient to check for a `link` property
        // as String.prototype.link is a valid (although deprecated) method
        return typeof item === 'object'
            && typeof item?.link === 'object';
    }
    isLinkWithOptions(item) {
        // NOTE: it is not sufficient to check for a `link` property
        // as String.prototype.link is a valid (although deprecated) method
        return typeof item === 'object'
            && typeof item?.link === 'object';
    }
    getLinkOptions(item) {
        return item?.link;
    }
    ngOnInit() {
        if (!this.editor) {
            throw new NgxEditorError('Required editor instance to initialize menu component');
        }
        this.menuService.editor = this.editor;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuComponent, deps: [{ token: MenuService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: MenuComponent, selector: "ngx-editor-menu", inputs: { toolbar: "toolbar", colorPresets: "colorPresets", disabled: "disabled", editor: "editor", customMenuRef: "customMenuRef", dropdownPlacement: "dropdownPlacement" }, providers: [MenuService], ngImport: i0, template: "<div\n  class=\"NgxEditor__MenuBar\"\n  [ngClass]=\"{ 'NgxEditor--Disabled': disabled, 'NgxEditor__MenuBar--Reverse': dropdownPlacement === 'top' }\"\n>\n  <ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last; trackBy: trackByIndex\">\n    <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last; trackBy: trackByIndex\">\n      <!-- toggle icons -->\n      <ngx-toggle-command [toolbarItem]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"toggleCommands.includes(item)\">\n      </ngx-toggle-command>\n\n      <ngx-insert-command [toolbarItem]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"insertCommands.includes(item)\">\n      </ngx-insert-command>\n\n      <!-- link -->\n      <ng-container *ngIf=\"isLinkItem(item)\">\n        <ngx-link [class]=\"iconContainerClass\" [options]=\"getLinkOptions(item)\"></ngx-link>\n      </ng-container>\n\n      <!-- image -->\n      <ngx-image [class]=\"iconContainerClass\" *ngIf=\"item === 'image'\"> </ngx-image>\n\n      <!-- dropdown -->\n      <ng-container *ngIf=\"isDropDown(item)\">\n        <ngx-dropdown\n          *ngFor=\"let dropdownItem of getDropdownItems(item) | keyvalue; trackBy: trackByIndex\"\n          [class]=\"dropdownContainerClass\"\n          [group]=\"dropdownItem.key\"\n          [items]=\"dropdownItem.value\"\n        >\n        </ngx-dropdown>\n      </ng-container>\n\n      <!-- text color picker -->\n      <ngx-color-picker\n        [class]=\"iconContainerClass\"\n        *ngIf=\"item === 'text_color'\"\n        type=\"text_color\"\n        [presets]=\"presets\"\n      >\n      </ngx-color-picker>\n      <!-- background color picker -->\n      <ngx-color-picker\n        [class]=\"iconContainerClass\"\n        *ngIf=\"item === 'background_color'\"\n        type=\"background_color\"\n        [presets]=\"presets\"\n      >\n      </ngx-color-picker>\n\n      <!-- seperator -->\n      <div [class]=\"seperatorClass\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n    </ng-container>\n  </ng-container>\n\n  <!-- custom menu -->\n  <ng-container *ngIf=\"customMenuRef\">\n    <ng-container [ngTemplateOutlet]=\"customMenuRef\"></ng-container>\n  </ng-container>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ToggleCommandComponent, selector: "ngx-toggle-command", inputs: ["toolbarItem"] }, { kind: "component", type: InsertCommandComponent, selector: "ngx-insert-command", inputs: ["toolbarItem"] }, { kind: "component", type: LinkComponent, selector: "ngx-link", inputs: ["options"] }, { kind: "component", type: DropdownComponent, selector: "ngx-dropdown", inputs: ["group", "items"] }, { kind: "component", type: ImageComponent, selector: "ngx-image" }, { kind: "component", type: ColorPickerComponent, selector: "ngx-color-picker", inputs: ["presets", "type"] }, { kind: "pipe", type: i3.KeyValuePipe, name: "keyvalue" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-editor-menu', providers: [MenuService], template: "<div\n  class=\"NgxEditor__MenuBar\"\n  [ngClass]=\"{ 'NgxEditor--Disabled': disabled, 'NgxEditor__MenuBar--Reverse': dropdownPlacement === 'top' }\"\n>\n  <ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last; trackBy: trackByIndex\">\n    <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last; trackBy: trackByIndex\">\n      <!-- toggle icons -->\n      <ngx-toggle-command [toolbarItem]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"toggleCommands.includes(item)\">\n      </ngx-toggle-command>\n\n      <ngx-insert-command [toolbarItem]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"insertCommands.includes(item)\">\n      </ngx-insert-command>\n\n      <!-- link -->\n      <ng-container *ngIf=\"isLinkItem(item)\">\n        <ngx-link [class]=\"iconContainerClass\" [options]=\"getLinkOptions(item)\"></ngx-link>\n      </ng-container>\n\n      <!-- image -->\n      <ngx-image [class]=\"iconContainerClass\" *ngIf=\"item === 'image'\"> </ngx-image>\n\n      <!-- dropdown -->\n      <ng-container *ngIf=\"isDropDown(item)\">\n        <ngx-dropdown\n          *ngFor=\"let dropdownItem of getDropdownItems(item) | keyvalue; trackBy: trackByIndex\"\n          [class]=\"dropdownContainerClass\"\n          [group]=\"dropdownItem.key\"\n          [items]=\"dropdownItem.value\"\n        >\n        </ngx-dropdown>\n      </ng-container>\n\n      <!-- text color picker -->\n      <ngx-color-picker\n        [class]=\"iconContainerClass\"\n        *ngIf=\"item === 'text_color'\"\n        type=\"text_color\"\n        [presets]=\"presets\"\n      >\n      </ngx-color-picker>\n      <!-- background color picker -->\n      <ngx-color-picker\n        [class]=\"iconContainerClass\"\n        *ngIf=\"item === 'background_color'\"\n        type=\"background_color\"\n        [presets]=\"presets\"\n      >\n      </ngx-color-picker>\n\n      <!-- seperator -->\n      <div [class]=\"seperatorClass\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n    </ng-container>\n  </ng-container>\n\n  <!-- custom menu -->\n  <ng-container *ngIf=\"customMenuRef\">\n    <ng-container [ngTemplateOutlet]=\"customMenuRef\"></ng-container>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: () => [{ type: MenuService }], propDecorators: { toolbar: [{
                type: Input
            }], colorPresets: [{
                type: Input
            }], disabled: [{
                type: Input
            }], editor: [{
                type: Input
            }], customMenuRef: [{
                type: Input
            }], dropdownPlacement: [{
                type: Input
            }] } });

class BubbleComponent {
    constructor(sanitizeHTML, ngxeService) {
        this.sanitizeHTML = sanitizeHTML;
        this.ngxeService = ngxeService;
        this.execulableItems = [];
        this.activeItems = [];
        this.toolbar = [
            ['bold', 'italic', 'underline', 'strike'],
            ['ordered_list', 'bullet_list', 'blockquote', 'code'],
            ['align_left', 'align_center', 'align_right', 'align_justify'],
        ];
        this.toggleCommands = [
            'bold',
            'italic',
            'underline',
            'strike',
            'ordered_list',
            'bullet_list',
            'blockquote',
            'code',
            'align_left',
            'align_center',
            'align_right',
            'align_justify',
        ];
    }
    get view() {
        return this.editor.view;
    }
    getIcon(name) {
        return this.sanitizeHTML.transform(this.ngxeService.getIcon(name));
    }
    getTitle(name) {
        return this.ngxeService.locals.get(name);
    }
    trackByIndex(index) {
        return index;
    }
    onClick(e, commandName) {
        e.preventDefault();
        e.stopPropagation();
        if (e.button !== 0) {
            return;
        }
        const { state, dispatch } = this.view;
        const command = ToggleCommands[commandName];
        command.toggle()(state, dispatch);
    }
    update(view) {
        this.activeItems = [];
        this.execulableItems = [];
        const { state } = view;
        this.toggleCommands.forEach((toolbarItem) => {
            const command = ToggleCommands[toolbarItem];
            const isActive = command.isActive(state);
            if (isActive) {
                this.activeItems.push(toolbarItem);
            }
            const canExecute = command.canExecute(state);
            if (canExecute) {
                this.execulableItems.push(toolbarItem);
            }
        });
    }
    ngOnInit() {
        this.updateSubscription = this.editor.update
            .subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: BubbleComponent, deps: [{ token: SanitizeHtmlPipe }, { token: NgxEditorService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: BubbleComponent, selector: "ngx-bubble", inputs: { editor: "editor" }, ngImport: i0, template: "<ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last; trackBy: trackByIndex\">\n  <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last; trackBy: trackByIndex\">\n    <button\n      type=\"button\"\n      class=\"NgxBubbleMenu__Icon\"\n      *ngIf=\"toggleCommands.includes(item)\"\n      [ngClass]=\"{\n        'NgxBubbleMenu__Icon--Active': this.activeItems.includes(item),\n        'NgxEditor--Disabled': !this.execulableItems.includes(item)\n      }\"\n      (mousedown)=\"onClick($event, item)\"\n      [title]=\"getTitle(item) | async\"\n      [innerHTML]=\"getIcon(item)\"\n    ></button>\n    <div class=\"NgxBubbleMenu__Seperator\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n  </ng-container>\n</ng-container>\n", styles: ["*,*:before,*:after{box-sizing:border-box}:host{display:flex;flex-wrap:wrap;background-color:var(--ngx-editor-bubble-bg-color);color:var(--ngx-editor-bubble-text-color);padding:5px;border-radius:4px}.NgxBubbleMenu__Icon{all:unset;appearance:none;height:var(--ngx-editor-icon-size);width:var(--ngx-editor-icon-size);transition:.2s ease-in-out;border-radius:var(--ngx-editor-menu-item-border-radius);display:flex;align-items:center;justify-content:center;color:#fff}.NgxBubbleMenu__Icon:hover{background-color:var(--ngx-editor-bubble-item-hover-color)}.NgxBubbleMenu__Icon+.NgxBubbleMenu__Icon{margin-left:5px}.NgxBubbleMenu__Icon.NgxBubbleMenu__Icon--Active{background-color:var(--ngx-editor-bubble-text-color);color:var(--ngx-editor-bubble-bg-color)}.NgxBubbleMenu__Seperator{border-left:1px solid var(--ngx-editor-seperator-color);margin:0 5px}\n"], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: BubbleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-bubble', template: "<ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last; trackBy: trackByIndex\">\n  <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last; trackBy: trackByIndex\">\n    <button\n      type=\"button\"\n      class=\"NgxBubbleMenu__Icon\"\n      *ngIf=\"toggleCommands.includes(item)\"\n      [ngClass]=\"{\n        'NgxBubbleMenu__Icon--Active': this.activeItems.includes(item),\n        'NgxEditor--Disabled': !this.execulableItems.includes(item)\n      }\"\n      (mousedown)=\"onClick($event, item)\"\n      [title]=\"getTitle(item) | async\"\n      [innerHTML]=\"getIcon(item)\"\n    ></button>\n    <div class=\"NgxBubbleMenu__Seperator\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n  </ng-container>\n</ng-container>\n", styles: ["*,*:before,*:after{box-sizing:border-box}:host{display:flex;flex-wrap:wrap;background-color:var(--ngx-editor-bubble-bg-color);color:var(--ngx-editor-bubble-text-color);padding:5px;border-radius:4px}.NgxBubbleMenu__Icon{all:unset;appearance:none;height:var(--ngx-editor-icon-size);width:var(--ngx-editor-icon-size);transition:.2s ease-in-out;border-radius:var(--ngx-editor-menu-item-border-radius);display:flex;align-items:center;justify-content:center;color:#fff}.NgxBubbleMenu__Icon:hover{background-color:var(--ngx-editor-bubble-item-hover-color)}.NgxBubbleMenu__Icon+.NgxBubbleMenu__Icon{margin-left:5px}.NgxBubbleMenu__Icon.NgxBubbleMenu__Icon--Active{background-color:var(--ngx-editor-bubble-text-color);color:var(--ngx-editor-bubble-bg-color)}.NgxBubbleMenu__Seperator{border-left:1px solid var(--ngx-editor-seperator-color);margin:0 5px}\n"] }]
        }], ctorParameters: () => [{ type: SanitizeHtmlPipe }, { type: NgxEditorService }], propDecorators: { editor: [{
                type: Input
            }] } });

class FloatingMenuComponent {
    constructor(el) {
        this.el = el;
        this.autoPlace = false;
        this.posLeft = 0;
        this.posTop = 0;
        this.showMenu = false;
        this.dragging = false;
    }
    get display() {
        return {
            visibility: this.showMenu ? 'visible' : 'hidden',
            opacity: this.showMenu ? '1' : '0',
            top: `${this.posTop}px`,
            left: `${this.posLeft}px`,
        };
    }
    get view() {
        return this.editor.view;
    }
    onMouseDown(e) {
        const target = e.target;
        if (this.el.nativeElement.contains(target) && target.nodeName !== 'INPUT') {
            e.preventDefault();
            return;
        }
        this.dragging = true;
    }
    onKeyDown(e) {
        const target = e.target;
        if (target.nodeName === 'INPUT') {
            return;
        }
        this.dragging = true;
        this.hide();
    }
    onMouseUp(e) {
        const target = e.target;
        if (this.el.nativeElement.contains(target) || target.nodeName === 'INPUT') {
            e.preventDefault();
            return;
        }
        this.dragging = false;
        this.useUpdate();
    }
    onKeyUp(e) {
        const target = e.target;
        if (target.nodeName === 'INPUT') {
            return;
        }
        this.dragging = false;
        this.useUpdate();
    }
    useUpdate() {
        if (!this.view) {
            return;
        }
        this.update(this.view);
    }
    hide() {
        this.showMenu = false;
    }
    show() {
        this.showMenu = true;
    }
    async calculateBubblePosition(view) {
        const { state: { selection } } = view;
        const { from, to } = selection;
        const start = view.coordsAtPos(from);
        const end = view.coordsAtPos(to);
        const selectionElement = {
            getBoundingClientRect() {
                if (selection instanceof NodeSelection) {
                    const node = view.nodeDOM(from);
                    return node.getBoundingClientRect();
                }
                const { top, left } = start;
                const { bottom, right } = end;
                return {
                    x: left,
                    y: top,
                    top,
                    bottom,
                    left,
                    right,
                    width: right - left,
                    height: bottom - top,
                };
            },
        };
        // the floating bubble itself
        const bubbleEl = this.el.nativeElement;
        const { x: left, y: top } = await computePosition(selectionElement, bubbleEl, {
            placement: 'top',
            middleware: [
                offset(5),
                this.autoPlace && autoPlacement({
                    boundary: view.dom,
                    padding: 5,
                    allowedPlacements: ['top', 'bottom'],
                }),
                {
                    // prevent overflow on right and left side
                    // since only top and bottom placements are allowed
                    // autoplacement can't handle overflows on the right and left
                    name: 'overflowMiddleware',
                    async fn(middlewareArgs) {
                        const overflow = await detectOverflow(middlewareArgs, {
                            boundary: view.dom,
                            padding: 5,
                        });
                        // overflows left
                        if (overflow.left > 0) {
                            return {
                                x: middlewareArgs.x + overflow.left,
                            };
                        }
                        // overflows right
                        if (overflow.right > 0) {
                            return {
                                x: middlewareArgs.x - overflow.right,
                            };
                        }
                        return {};
                    },
                },
            ].filter(Boolean),
        });
        return {
            left,
            top,
        };
    }
    canShowMenu(view) {
        const { state } = view;
        const { selection } = state;
        const { empty } = selection;
        if (selection instanceof NodeSelection) {
            if (selection.node.type.name === 'image') {
                return false;
            }
        }
        const hasFocus = this.view.hasFocus();
        if (!hasFocus || empty || this.dragging) {
            this.hide();
            return false;
        }
        return true;
    }
    update(view) {
        const canShowMenu = this.canShowMenu(view);
        if (!canShowMenu) {
            this.hide();
            return;
        }
        this.calculateBubblePosition(this.view).then(({ top, left }) => {
            if (!this.canShowMenu) {
                this.hide();
                return;
            }
            this.posLeft = left;
            this.posTop = top;
            this.show();
        });
    }
    ngOnInit() {
        if (!this.editor) {
            throw new NgxEditorError('Required editor instance to initialize floating menu component');
        }
        this.updateSubscription = this.editor.update
            .subscribe((view) => {
            this.update(view);
        });
        this.resizeSubscription = fromEvent(window, 'resize').pipe(throttleTime(500, asyncScheduler, { leading: true, trailing: true })).subscribe(() => {
            this.useUpdate();
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
        this.resizeSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FloatingMenuComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: FloatingMenuComponent, selector: "ngx-editor-floating-menu", inputs: { editor: "editor", autoPlace: "autoPlace" }, host: { listeners: { "document:mousedown": "onMouseDown($event)", "document:keydown": "onKeyDown($event)", "document:mouseup": "onMouseUp($event)", "document:keyup": "onKeyUp($event)" }, properties: { "style": "this.display" } }, ngImport: i0, template: "<div #ref>\n  <ng-content></ng-content>\n</div>\n<ng-container *ngIf=\"ref.children.length === 0\">\n  <ngx-bubble [editor]=\"editor\"></ngx-bubble>\n</ng-container>\n", styles: ["*,*:before,*:after{box-sizing:border-box}:host{position:absolute;z-index:20;margin-bottom:5px;visibility:hidden;opacity:0}\n"], dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: BubbleComponent, selector: "ngx-bubble", inputs: ["editor"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FloatingMenuComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-editor-floating-menu', template: "<div #ref>\n  <ng-content></ng-content>\n</div>\n<ng-container *ngIf=\"ref.children.length === 0\">\n  <ngx-bubble [editor]=\"editor\"></ngx-bubble>\n</ng-container>\n", styles: ["*,*:before,*:after{box-sizing:border-box}:host{position:absolute;z-index:20;margin-bottom:5px;visibility:hidden;opacity:0}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { display: [{
                type: HostBinding,
                args: ['style']
            }], editor: [{
                type: Input
            }], autoPlace: [{
                type: Input
            }], onMouseDown: [{
                type: HostListener,
                args: ['document:mousedown', ['$event']]
            }], onKeyDown: [{
                type: HostListener,
                args: ['document:keydown', ['$event']]
            }], onMouseUp: [{
                type: HostListener,
                args: ['document:mouseup', ['$event']]
            }], onKeyUp: [{
                type: HostListener,
                args: ['document:keyup', ['$event']]
            }] } });

class MenuModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: MenuModule, declarations: [
            // pipes
            SanitizeHtmlPipe,
            // components
            MenuComponent,
            ToggleCommandComponent,
            InsertCommandComponent,
            LinkComponent,
            DropdownComponent,
            ImageComponent,
            ColorPickerComponent,
            FloatingMenuComponent,
            BubbleComponent], imports: [CommonModule,
            ReactiveFormsModule], exports: [MenuComponent,
            FloatingMenuComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuModule, providers: [
            SanitizeHtmlPipe,
        ], imports: [CommonModule,
            ReactiveFormsModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: MenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                    ],
                    declarations: [
                        // pipes
                        SanitizeHtmlPipe,
                        // components
                        MenuComponent,
                        ToggleCommandComponent,
                        InsertCommandComponent,
                        LinkComponent,
                        DropdownComponent,
                        ImageComponent,
                        ColorPickerComponent,
                        FloatingMenuComponent,
                        BubbleComponent,
                    ],
                    providers: [
                        SanitizeHtmlPipe,
                    ],
                    exports: [
                        MenuComponent,
                        FloatingMenuComponent,
                    ],
                }]
        }] });

const NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');
const defaultConfig = {
    locals: defaults,
    icons,
};
class NgxEditorModule {
    static forRoot(config = defaultConfig) {
        return {
            ngModule: NgxEditorModule,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config,
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN],
                },
            ],
        };
    }
    static forChild(config = defaultConfig) {
        return {
            ngModule: NgxEditorModule,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config,
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN],
                },
                NgxEditorService,
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorModule, declarations: [NgxEditorComponent,
            ImageViewComponent], imports: [CommonModule,
            MenuModule], exports: [NgxEditorComponent,
            MenuComponent,
            FloatingMenuComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorModule, imports: [CommonModule,
            MenuModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgxEditorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MenuModule,
                    ],
                    providers: [],
                    declarations: [
                        NgxEditorComponent,
                        ImageViewComponent,
                    ],
                    exports: [
                        NgxEditorComponent,
                        MenuComponent,
                        FloatingMenuComponent,
                    ],
                }]
        }] });

const isEmptyInputValue = (value) => {
    // we don't check for string here so it also works with arrays
    return value === null || value.length === 0;
};
const hasValidLength = (value) => {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value !== null && typeof value.length === 'number';
};
const isDocEmpty = (doc) => {
    if (!doc) {
        return true;
    }
    const { childCount, firstChild } = doc;
    return Boolean(childCount === 1 && firstChild?.isTextblock && firstChild.content.size === 0);
};
// @dynamic
class Validators {
    static required(userSchema) {
        return (control) => {
            const schema$1 = userSchema || schema;
            const doc = parseContent(control.value, schema$1);
            const isEmpty = isDocEmpty(doc);
            if (!isEmpty) {
                return null;
            }
            return {
                required: true,
            };
        };
    }
    static maxLength(maxLength, userSchema) {
        return (control) => {
            const schema$1 = userSchema || schema;
            const doc = parseContent(control.value, schema$1);
            const value = doc.textContent;
            if (hasValidLength(value) && value.length > maxLength) {
                return {
                    maxlength: {
                        requiredLength: maxLength,
                        actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
    static minLength(minLength, userSchema) {
        return (control) => {
            const schema$1 = userSchema || schema;
            const doc = parseContent(control.value, schema$1);
            const value = doc.textContent;
            if (isEmptyInputValue(value) || !hasValidLength(value)) {
                // don't validate empty values to allow optional controls
                // don't validate values without `length` property
                return null;
            }
            if (value.length < minLength) {
                return {
                    minlength: {
                        requiredLength: minLength, actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
}

const execMark = (name, toggle = false) => {
    return (state, dispatch) => {
        const command = new Mark(name);
        if (!toggle) {
            return command.apply()(state, dispatch);
        }
        return command.toggle()(state, dispatch);
    };
};
class EditorCommands {
    constructor(view) {
        this.applyTrx = (tr) => {
            this.state = this.state.apply(tr ?? this.tr);
            this.tr = this.state.tr;
            this.tr.setMeta('APPLIED_TRX', true);
        };
        this.dispatch = (tr) => {
            this.applyTrx(tr);
        };
        if (!view) {
            throw new NgxEditorError('Required view to initialize commands.');
        }
        this.view = view;
        this.state = view.state;
        this.tr = this.view.state.tr;
    }
    exec() {
        // No changes applied
        if (!this.tr.getMeta('APPLIED_TRX')) {
            return false;
        }
        const forceEmit = !this.view.state.doc.eq(this.state.doc);
        this.view.updateState(this.state);
        const tr = this.tr
            .setMeta('FORCE_EMIT', forceEmit);
        this.view.dispatch(tr);
        return true;
    }
    focus(position = 'end') {
        const selection = position === 'start'
            ? Selection.atStart(this.state.doc)
            : Selection.atEnd(this.state.doc);
        this.tr.setSelection(selection);
        this.applyTrx();
        this.view.focus();
        return this;
    }
    scrollIntoView() {
        this.tr.scrollIntoView();
        this.applyTrx();
        return this;
    }
    insertText(text) {
        this.tr.insertText(text);
        this.applyTrx();
        return this;
    }
    insertNewLine() {
        const newLineCommands = [newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock];
        chainCommands(...newLineCommands)(this.state, this.dispatch);
        return this;
    }
    applyMark(name) {
        execMark(name, false)(this.state, this.dispatch);
        return this;
    }
    toggleMark(name) {
        execMark(name, true)(this.state, this.dispatch);
        return this;
    }
    bold() {
        execMark('strong')(this.state, this.dispatch);
        return this;
    }
    toggleBold() {
        execMark('strong', true)(this.state, this.dispatch);
        return this;
    }
    italics() {
        execMark('em')(this.state, this.dispatch);
        return this;
    }
    toggleItalics() {
        execMark('em', true)(this.state, this.dispatch);
        return this;
    }
    underline() {
        execMark('u')(this.state, this.dispatch);
        return this;
    }
    toggleUnderline() {
        execMark('u', true)(this.state, this.dispatch);
        return this;
    }
    strike() {
        execMark('s')(this.state, this.dispatch);
        return this;
    }
    toggleStrike() {
        execMark('s', true)(this.state, this.dispatch);
        return this;
    }
    code() {
        execMark('code')(this.state, this.dispatch);
        return this;
    }
    toggleCode() {
        execMark('code', true)(this.state, this.dispatch);
        return this;
    }
    superscript() {
        execMark('sup')(this.state, this.dispatch);
        return this;
    }
    subscript() {
        execMark('sub')(this.state, this.dispatch);
        return this;
    }
    toggleOrderedList() {
        const command = new ListItem(false);
        command.toggle()(this.state, this.dispatch);
        return this;
    }
    toggleBulletList() {
        const command = new ListItem(true);
        command.toggle()(this.state, this.dispatch);
        return this;
    }
    toggleHeading(level) {
        const command = new Heading(level);
        command.toggle()(this.state, this.dispatch);
        return this;
    }
    insertLink(text, attrs) {
        const command = new Link$1();
        command.insert(text, attrs)(this.state, this.dispatch);
        return this;
    }
    updateLink(attrs) {
        const command = new Link$1();
        command.update(attrs)(this.state, this.dispatch);
        return this;
    }
    insertImage(src, attrs = {}) {
        const command = new Image$1();
        command.insert(src, attrs)(this.state, this.dispatch);
        return this;
    }
    textColor(color) {
        const command = new TextColor$1('text_color');
        command.apply({ color })(this.state, this.dispatch);
        return this;
    }
    backgroundColor(color) {
        const command = new TextColor$1('text_background_color');
        command.apply({ backgroundColor: color })(this.state, this.dispatch);
        return this;
    }
    removeTextColor() {
        const command = new TextColor$1('text_color');
        command.remove()(this.state, this.dispatch);
        return this;
    }
    removeBackgroundColor() {
        const command = new TextColor$1('text_background_color');
        command.remove()(this.state, this.dispatch);
        return this;
    }
    align(p) {
        const command = new TextAlign(p);
        command.toggle()(this.state, this.dispatch);
        return this;
    }
    insertHTML(html) {
        const { selection, schema, tr } = this.state;
        const { from, to } = selection;
        const element = document.createElement('div');
        element.innerHTML = isString(html) ? html.trim() : html;
        const slice = DOMParser.fromSchema(schema).parseSlice(element);
        const transaction = tr.replaceRange(from, to, slice);
        this.applyTrx(transaction);
        return this;
    }
    indent() {
        const command = new Indent('increase');
        command.insert()(this.state, this.dispatch);
        return this;
    }
    outdent() {
        const command = new Indent('decrease');
        command.insert()(this.state, this.dispatch);
        return this;
    }
}

const isMacOs = typeof navigator !== 'undefined'
    ? (/Mac/).test(navigator.platform)
    : false;
// Input rules ref: https://github.com/ProseMirror/prosemirror-example-setup/
// : (NodeType) → InputRule
// Given a blockquote node type, returns an input rule that turns `"> "`
// at the start of a textblock into a blockquote.
const blockQuoteRule = (nodeType) => {
    return wrappingInputRule(/^\s*>\s$/, nodeType);
};
// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a number
// followed by a dot at the start of a textblock into an ordered list.
const orderedListRule = (nodeType) => {
    return wrappingInputRule(/^(?:\d+)\.\s$/, nodeType, (match) => ({ order: Number(match[1]) }), (match, node) => node.childCount + node.attrs['order'] === Number(match[1]));
};
// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a bullet
// (dash, plush, or asterisk) at the start of a textblock into a
// bullet list.
const bulletListRule = (nodeType) => {
    return wrappingInputRule(/^\s*(?:[-+*])\s$/, nodeType);
};
// : (NodeType) → InputRule
// Given a code block node type, returns an input rule that turns a
// textblock starting with three backticks into a code block.
const codeBlockRule = (nodeType) => {
    return textblockTypeInputRule(/^```$/, nodeType);
};
// : (NodeType, number) → InputRule
// Given a node type and a maximum level, creates an input rule that
// turns up to that number of `#` characters followed by a space at
// the start of a textblock into a heading whose level corresponds to
// the number of `#` signs.
const headingRule = (nodeType, maxLevel) => {
    return textblockTypeInputRule(new RegExp(`^(#{1,${maxLevel}})\\s$`), nodeType, (match) => ({ level: match[1].length }));
};
// : (MarkType) → InputRule
// Wraps matching text with bold mark
const boldRule = (markType) => {
    // eslint-disable-next-line prefer-named-capture-group
    return markInputRule(/(?:^|\s)(?:(\*\*|__)(?:([^*_]+))(\*\*|__))$/, markType);
};
// : (MarkType) → InputRule
// Wraps matching text with em mark
const emRule = (markType) => {
    // eslint-disable-next-line prefer-named-capture-group
    return markInputRule(/(?:^|\s)(?:(\*|_)(?:([^*_]+))(\*|_))$/, markType);
};
// : (Schema) → Plugin
// A set of input rules for creating the basic block quotes, lists,
// code blocks, and heading.
const buildInputRules = (schema) => {
    const rules = smartQuotes.concat(ellipsis, emDash);
    rules.push(boldRule(schema.marks['strong']));
    rules.push(emRule(schema.marks['em']));
    rules.push(blockQuoteRule(schema.nodes['blockquote']));
    rules.push(orderedListRule(schema.nodes['ordered_list']));
    rules.push(bulletListRule(schema.nodes['bullet_list']));
    rules.push(codeBlockRule(schema.nodes['code_block']));
    rules.push(headingRule(schema.nodes['heading'], 6));
    return inputRules({ rules });
};
const getKeyboardShortcuts = (schema, options) => {
    const historyKeyMap = {};
    historyKeyMap['Mod-z'] = undo$1;
    if (isMacOs) {
        historyKeyMap['Shift-Mod-z'] = redo$1;
    }
    else {
        historyKeyMap['Mod-y'] = redo$1;
    }
    const plugins = [
        keymap({
            'Mod-b': toggleMark(schema.marks['strong']),
            'Mod-i': toggleMark(schema.marks['em']),
            'Mod-u': toggleMark(schema.marks['u']),
            'Mod-`': toggleMark(schema.marks['code']),
        }),
        keymap({
            'Enter': splitListItem(schema.nodes['list_item']),
            'Shift-Enter': chainCommands(exitCode, (state, dispatch) => {
                const { tr } = state;
                const br = schema.nodes['hard_break'];
                dispatch(tr.replaceSelectionWith(br.create()).scrollIntoView());
                return true;
            }),
            'Mod-[': liftListItem(schema.nodes['list_item']),
            'Mod-]': sinkListItem(schema.nodes['list_item']),
            'Tab': sinkListItem(schema.nodes['list_item']),
        }),
        keymap(baseKeymap),
    ];
    if (options.history) {
        plugins.push(keymap(historyKeyMap));
    }
    return plugins;
};
const getDefaultPlugins = (schema, options) => {
    const plugins = [];
    if (options.keyboardShortcuts) {
        plugins.push(...getKeyboardShortcuts(schema, { history: options.history }));
    }
    if (options.history) {
        plugins.push(history());
    }
    if (options.inputRules) {
        plugins.push(buildInputRules(schema));
    }
    return plugins;
};

const defaultFeatures = {
    linkOnPaste: true,
    resizeImage: true,
};
const DEFAULT_OPTIONS = {
    content: null,
    history: true,
    keyboardShortcuts: true,
    inputRules: true,
    schema: schema,
    plugins: [],
    nodeViews: {},
    attributes: {},
    features: defaultFeatures,
    handleScrollToSelection: null,
    linkValidationPattern: '(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/??([^#\n\r]*)?#?([^\n\r]*)|(mailto:.*[@].*)',
};
class Editor {
    constructor(options = DEFAULT_OPTIONS) {
        this.valueChangesSubject = new Subject();
        this.updateSubject = new Subject();
        this.options = { ...DEFAULT_OPTIONS, ...options };
        this.createEditor();
    }
    get valueChanges() {
        return this.valueChangesSubject.asObservable();
    }
    get update() {
        return this.updateSubject.asObservable();
    }
    get schema() {
        return this.options.schema || schema;
    }
    get linkValidationPattern() {
        return this.options.linkValidationPattern;
    }
    get commands() {
        return new EditorCommands(this.view);
    }
    get features() {
        return { ...defaultFeatures, ...this.options.features };
    }
    handleTransactions(tr) {
        const state = this.view.state.apply(tr);
        this.view.updateState(state);
        this.updateSubject.next(this.view);
        if (!tr.docChanged && !tr.getMeta('FORCE_EMIT')) {
            return;
        }
        const json = state.doc.toJSON();
        this.valueChangesSubject.next(json);
    }
    createEditor() {
        const { options, schema } = this;
        const { content = null, nodeViews } = options;
        const { history = true, keyboardShortcuts = true, inputRules = true } = options;
        const doc = parseContent(content, schema, options.parseOptions);
        const plugins = options.plugins ?? [];
        const attributes = options.attributes ?? {};
        const defaultPlugins = getDefaultPlugins(schema, {
            history,
            keyboardShortcuts,
            inputRules,
        });
        this.view = new EditorView(null, {
            state: EditorState.create({
                doc,
                schema,
                plugins: [...defaultPlugins, ...plugins],
            }),
            nodeViews,
            dispatchTransaction: this.handleTransactions.bind(this),
            attributes,
            handleScrollToSelection: options.handleScrollToSelection,
        });
    }
    setContent(content) {
        if (isNil(content)) {
            return;
        }
        const { state } = this.view;
        const { tr, doc } = state;
        const newDoc = parseContent(content, this.schema, this.options.parseOptions);
        tr.replaceWith(0, state.doc.content.size, newDoc);
        // don't emit if both content is same
        if (doc.eq(tr.doc)) {
            return;
        }
        if (!tr.docChanged) {
            return;
        }
        this.view.dispatch(tr);
    }
    registerPlugin(plugin) {
        const { state } = this.view;
        const plugins = [...state.plugins, plugin];
        const newState = state.reconfigure({ plugins });
        this.view.updateState(newState);
    }
    destroy() {
        this.view.destroy();
    }
}

/*
 * Public API Surface of ngx-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_TOOLBAR, Editor, FloatingMenuComponent, ImageViewComponent, MenuComponent, NGX_EDITOR_CONFIG_TOKEN, NgxEditorComponent, NgxEditorModule, NgxEditorService, TOOLBAR_FULL, TOOLBAR_MINIMAL, Validators, emptyDoc, getKeyboardShortcuts, parseContent, provideMyServiceOptions, toDoc, toHTML };
//# sourceMappingURL=ngx-editor.mjs.map

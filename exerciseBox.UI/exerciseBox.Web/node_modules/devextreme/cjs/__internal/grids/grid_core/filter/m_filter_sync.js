/**
 * DevExtreme (cjs/__internal/grids/grid_core/filter/m_filter_sync.js)
 * Version: 23.2.4
 * Build date: Mon Jan 29 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.filterSyncModule = void 0;
var _deferred = require("../../../../core/utils/deferred");
var _type = require("../../../../core/utils/type");
var _filtering = _interopRequireDefault(require("../../../../ui/shared/filtering"));
var _ui = _interopRequireDefault(require("../../../../ui/widget/ui.errors"));
var _m_utils = require("../../../filter_builder/m_utils");
var _m_modules = _interopRequireDefault(require("../m_modules"));
var _m_utils2 = _interopRequireDefault(require("../m_utils"));
var _m_filter_custom_operations = require("./m_filter_custom_operations");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}
const FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
const FILTER_TYPES_INCLUDE = "include";
const FILTER_TYPES_EXCLUDE = "exclude";

function getColumnIdentifier(column) {
    return column.name || column.dataField
}

function checkForErrors(columns) {
    columns.forEach(column => {
        const identifier = getColumnIdentifier(column);
        if (!(0, _type.isDefined)(identifier) && column.allowFiltering) {
            throw new _ui.default.Error("E1049", column.caption)
        }
    })
}
const FilterSyncController = _m_modules.default.Controller.inherit(function() {
    const canSyncHeaderFilterWithFilterRow = function(column) {
        const filterValues = column.filterValues || [];
        return !_filtering.default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource) || 1 === filterValues.length && null === filterValues[0]
    };
    const getConditionFromFilterRow = function(column) {
        const value = column.filterValue;
        if ((0, _type.isDefined)(value)) {
            const operation = column.selectedFilterOperation || column.defaultFilterOperation || (0, _m_utils.getDefaultOperation)(column);
            const filter = [getColumnIdentifier(column), operation, column.filterValue];
            return filter
        }
        return null
    };
    const getConditionFromHeaderFilter = function(column) {
        let selectedOperation;
        let value;
        const {
            filterValues: filterValues
        } = column;
        if (!filterValues) {
            return null
        }
        if (1 === filterValues.length && canSyncHeaderFilterWithFilterRow(column) && !Array.isArray(filterValues[0])) {
            "exclude" === column.filterType ? selectedOperation = "<>" : selectedOperation = "=";
            value = filterValues[0]
        } else {
            "exclude" === column.filterType ? selectedOperation = "noneof" : selectedOperation = "anyof";
            value = filterValues
        }
        return [getColumnIdentifier(column), selectedOperation, value]
    };
    const updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
        const headerFilter = function(headerFilterCondition, column) {
            if (!headerFilterCondition) {
                return {
                    filterType: "include",
                    filterValues: void 0
                }
            }
            let filterType;
            const selectedFilterOperation = headerFilterCondition[1];
            const value = headerFilterCondition[2];
            const hasArrayValue = Array.isArray(value);
            if (!hasArrayValue) {
                if (!canSyncHeaderFilterWithFilterRow(column)) {
                    return {
                        filterType: "include",
                        filterValues: void 0
                    }
                }
            }
            switch (selectedFilterOperation) {
                case "anyof":
                case "=":
                    filterType = "include";
                    break;
                case "noneof":
                case "<>":
                    filterType = "exclude";
                    break;
                default:
                    return {
                        filterType: "include", filterValues: void 0
                    }
            }
            return {
                filterType: filterType,
                filterValues: hasArrayValue ? value : [value]
            }
        }(headerFilterCondition, column);
        columnsController.columnOption(getColumnIdentifier(column), headerFilter)
    };
    const updateFilterRowCondition = function(columnsController, column, condition) {
        let filterRowOptions;
        let selectedFilterOperation = null === condition || void 0 === condition ? void 0 : condition[1];
        const filterValue = null === condition || void 0 === condition ? void 0 : condition[2];
        const filterOperations = column.filterOperations || column.defaultFilterOperations;
        if ((!filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0 || selectedFilterOperation === column.defaultFilterOperation) && FILTER_ROW_OPERATIONS.includes(selectedFilterOperation) && null !== filterValue) {
            if (selectedFilterOperation === column.defaultFilterOperation && !(0, _type.isDefined)(column.selectedFilterOperation)) {
                selectedFilterOperation = column.selectedFilterOperation
            }
            filterRowOptions = {
                filterValue: filterValue,
                selectedFilterOperation: selectedFilterOperation
            }
        } else {
            filterRowOptions = {
                filterValue: void 0,
                selectedFilterOperation: void 0
            }
        }
        columnsController.columnOption(getColumnIdentifier(column), filterRowOptions)
    };
    return {
        syncFilterValue() {
            const that = this;
            const columnsController = that.getController("columns");
            const columns = columnsController.getFilteringColumns();
            this._skipSyncColumnOptions = true;
            columns.forEach(column => {
                const filterConditions = (0, _m_utils.getMatchedConditions)(that.option("filterValue"), getColumnIdentifier(column));
                if (1 === filterConditions.length) {
                    const filterCondition = filterConditions[0];
                    updateHeaderFilterCondition(columnsController, column, filterCondition);
                    updateFilterRowCondition(columnsController, column, filterCondition)
                } else {
                    (0, _type.isDefined)(column.filterValues) && updateHeaderFilterCondition(columnsController, column, null);
                    (0, _type.isDefined)(column.filterValue) && updateFilterRowCondition(columnsController, column, null)
                }
            });
            this._skipSyncColumnOptions = false
        },
        _initSync() {
            const columns = this.getController("columns").getColumns();
            const dataController = this.getController("data");
            const pageIndex = dataController.pageIndex();
            checkForErrors(columns);
            if (!this.option("filterValue")) {
                const filteringColumns = this.getController("columns").getFilteringColumns();
                const filterValue = this.getFilterValueFromColumns(filteringColumns);
                this._silentOption("filterValue", filterValue)
            }
            this.syncFilterValue();
            dataController.pageIndex(pageIndex)
        },
        init() {
            const dataController = this.getController("data");
            if (dataController.isFilterSyncActive()) {
                if (this.getController("columns").isAllDataTypesDefined()) {
                    this._initSync()
                } else {
                    dataController.dataSourceChanged.add(() => this._initSync())
                }
            }
        },
        _getSyncFilterRow(filterValue, column) {
            const filter = getConditionFromFilterRow(column);
            if ((0, _type.isDefined)(filter)) {
                return (0, _m_utils.syncFilters)(filterValue, filter)
            }
            return (0, _m_utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(column))
        },
        _getSyncHeaderFilter(filterValue, column) {
            const filter = getConditionFromHeaderFilter(column);
            if (filter) {
                return (0, _m_utils.syncFilters)(filterValue, filter)
            }
            return (0, _m_utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(column))
        },
        getFilterValueFromColumns(columns) {
            if (!this.getController("data").isFilterSyncActive()) {
                return null
            }
            const filterValue = ["and"];
            columns && columns.forEach(column => {
                const headerFilter = getConditionFromHeaderFilter(column);
                const filterRow = getConditionFromFilterRow(column);
                headerFilter && (0, _m_utils.addItem)(headerFilter, filterValue);
                filterRow && (0, _m_utils.addItem)(filterRow, filterValue)
            });
            return (0, _m_utils.getNormalizedFilter)(filterValue)
        },
        syncFilterRow(column) {
            this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column))
        },
        syncHeaderFilter(column) {
            this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column))
        },
        getCustomFilterOperations() {
            const filterBuilderCustomOperations = this.option("filterBuilder.customOperations") || [];
            return [(0, _m_filter_custom_operations.anyOf)(this.component), (0, _m_filter_custom_operations.noneOf)(this.component)].concat(filterBuilderCustomOperations)
        },
        publicMethods: () => ["getCustomFilterOperations"]
    }
}());
const DataControllerFilterSyncExtender = {
    isFilterSyncActive() {
        const filterSyncEnabledValue = this.option("filterSyncEnabled");
        return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue
    },
    skipCalculateColumnFilters() {
        const filterSyncController = this.getController("filterSync");
        return ((0, _type.isDefined)(this.option("filterValue")) || filterSyncController._skipSyncColumnOptions) && this.isFilterSyncActive()
    },
    _calculateAdditionalFilter() {
        if (false === this.option("filterPanel.filterEnabled")) {
            return this.callBase()
        }
        const filters = [this.callBase()];
        const columns = this.getController("columns").getFilteringColumns();
        let filterValue = this.option("filterValue");
        if (this.isFilterSyncActive()) {
            const currentColumnForHeaderFilter = this.getController("headerFilter").getCurrentColumn();
            const currentColumnForFilterRow = this.getController("applyFilter").getCurrentColumnForFiltering();
            const currentColumn = currentColumnForHeaderFilter || currentColumnForFilterRow;
            const needRemoveCurrentColumnFilter = currentColumnForHeaderFilter || (0, _type.isDefined)(null === currentColumnForFilterRow || void 0 === currentColumnForFilterRow ? void 0 : currentColumnForFilterRow.filterValue);
            if (needRemoveCurrentColumnFilter && filterValue) {
                filterValue = (0, _m_utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(currentColumn))
            }
        }
        const customOperations = this.getController("filterSync").getCustomFilterOperations();
        const calculatedFilterValue = (0, _m_utils.getFilterExpression)(filterValue, columns, customOperations, "filterBuilder");
        if (calculatedFilterValue) {
            filters.push(calculatedFilterValue)
        }
        return _m_utils2.default.combineFilters(filters)
    },
    _parseColumnPropertyName(fullName) {
        const matched = fullName.match(/.*\.(.*)/);
        if (matched) {
            return matched[1]
        }
        return null
    },
    clearFilter(filterName) {
        this.component.beginUpdate();
        if (arguments.length > 0) {
            if ("filterValue" === filterName) {
                this.option("filterValue", null)
            }
            this.callBase(filterName)
        } else {
            this.option("filterValue", null);
            this.callBase()
        }
        this.component.endUpdate()
    },
    optionChanged(args) {
        switch (args.name) {
            case "filterValue":
                this._applyFilter();
                this.isFilterSyncActive() && this.getController("filterSync").syncFilterValue();
                args.handled = true;
                break;
            case "filterSyncEnabled":
                args.handled = true;
                break;
            case "columns":
                if (this.isFilterSyncActive()) {
                    const column = this.getController("columns").getColumnByPath(args.fullName);
                    const filterSyncController = this.getController("filterSync");
                    if (column && !filterSyncController._skipSyncColumnOptions) {
                        const propertyName = this._parseColumnPropertyName(args.fullName);
                        filterSyncController._skipSyncColumnOptions = true;
                        if ("filterType" === propertyName) {
                            if ("exclude" === args.value || "exclude" === args.previousValue) {
                                filterSyncController.syncHeaderFilter(column)
                            }
                        } else if ("filterValues" === propertyName) {
                            filterSyncController.syncHeaderFilter(column)
                        } else if (["filterValue", "selectedFilterOperation"].includes(propertyName)) {
                            filterSyncController.syncFilterRow(column, column.filterValue)
                        }
                        filterSyncController._skipSyncColumnOptions = false
                    }
                }
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    _applyFilter() {
        const filterSyncController = this.getController("filterSync");
        if (filterSyncController._skipSyncColumnOptions) {
            return (new _deferred.Deferred).resolve()
        }
        return this.callBase.apply(this, arguments)
    }
};
const ColumnHeadersViewFilterSyncExtender = {
    _isHeaderFilterEmpty(column) {
        if (this.getController("data").isFilterSyncActive()) {
            return !(0, _m_utils.filterHasField)(this.option("filterValue"), getColumnIdentifier(column))
        }
        return this.callBase(column)
    },
    _needUpdateFilterIndicators() {
        return !this.getController("data").isFilterSyncActive()
    },
    optionChanged(args) {
        if ("filterValue" === args.name) {
            this._updateHeaderFilterIndicators()
        } else {
            this.callBase(args)
        }
    }
};
const filterSyncModule = {
    defaultOptions: () => ({
        filterValue: null,
        filterSyncEnabled: "auto"
    }),
    controllers: {
        filterSync: FilterSyncController
    },
    extenders: {
        controllers: {
            data: DataControllerFilterSyncExtender
        },
        views: {
            columnHeadersView: ColumnHeadersViewFilterSyncExtender
        }
    }
};
exports.filterSyncModule = filterSyncModule;

/**
 * DevExtreme (bundles/__internal/grids/grid_core/focus/m_focus.js)
 * Version: 23.2.4
 * Build date: Mon Jan 29 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.focusModule = void 0;
var _renderer = _interopRequireDefault(require("../../../../core/renderer"));
var _common = require("../../../../core/utils/common");
var _deferred = require("../../../../core/utils/deferred");
var _iterator = require("../../../../core/utils/iterator");
var _type = require("../../../../core/utils/type");
var _m_editing_utils = require("../editing/m_editing_utils");
var _m_modules = _interopRequireDefault(require("../m_modules"));
var _m_utils = _interopRequireDefault(require("../m_utils"));
var _m_focus_utils = require("./m_focus_utils");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}
const ROW_FOCUSED_CLASS = "dx-row-focused";
const FOCUSED_ROW_SELECTOR = ".dx-row.".concat("dx-row-focused");
const TABLE_POSTFIX_CLASS = "table";
const CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
const FocusController = _m_modules.default.ViewController.inherit(function() {
    const members = {
        init() {
            this._dataController = this.getController("data");
            this._keyboardController = this.getController("keyboardNavigation");
            this.component._optionsByReference.focusedRowKey = true
        },
        optionChanged(args) {
            const {
                name: name,
                value: value,
                previousValue: previousValue
            } = args;
            switch (name) {
                case "focusedRowIndex":
                    this._focusRowByIndex(value);
                    this._keyboardController._fireFocusedRowChanged();
                    args.handled = true;
                    break;
                case "focusedRowKey":
                    if (Array.isArray(value) && JSON.stringify(value) === JSON.stringify(previousValue)) {
                        return
                    }
                    this._focusRowByKey(value);
                    this._keyboardController._fireFocusedRowChanged();
                    args.handled = true;
                    break;
                case "focusedColumnIndex":
                case "focusedRowEnabled":
                case "autoNavigateToFocusedRow":
                    args.handled = true;
                    break;
                default:
                    this.callBase(args)
            }
        },
        isAutoNavigateToFocusedRow() {
            return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow")
        },
        _focusRowByIndex(index, operationTypes) {
            if (!this.option("focusedRowEnabled")) {
                return
            }
            index = void 0 !== index ? index : this.option("focusedRowIndex");
            if (index < 0) {
                if (this.isAutoNavigateToFocusedRow()) {
                    this._resetFocusedRow()
                }
            } else {
                this._focusRowByIndexCore(index, operationTypes)
            }
        },
        _focusRowByIndexCore(index, operationTypes) {
            const dataController = this.getController("data");
            const pageSize = dataController.pageSize();
            const setKeyByIndex = () => {
                if (this._isValidFocusedRowIndex(index)) {
                    let rowIndex = index - dataController.getRowIndexOffset(true);
                    if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
                        const lastItemIndex = dataController._getLastItemIndex();
                        rowIndex = Math.min(rowIndex, lastItemIndex)
                    }
                    const focusedRowKey = dataController.getKeyByRowIndex(rowIndex, true);
                    if ((0, _type.isDefined)(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
                        this.option("focusedRowKey", focusedRowKey)
                    }
                }
            };
            if (pageSize >= 0) {
                if (!this._isLocalRowIndex(index)) {
                    const pageIndex = Math.floor(index / dataController.pageSize());
                    (0, _deferred.when)(dataController.pageIndex(pageIndex), dataController.waitReady()).done(() => {
                        setKeyByIndex()
                    })
                } else {
                    setKeyByIndex()
                }
            }
        },
        _isLocalRowIndex(index) {
            const dataController = this.getController("data");
            const isVirtualScrolling = this.getController("keyboardNavigation")._isVirtualScrolling();
            if (isVirtualScrolling) {
                const pageIndex = Math.floor(index / dataController.pageSize());
                const virtualItems = dataController.virtualItemsCount();
                const virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
                const visibleRowsCount = dataController.getVisibleRows().length + dataController.getRowIndexOffset();
                const visiblePagesCount = Math.ceil(visibleRowsCount / dataController.pageSize());
                return virtualItemsBegin <= index && visiblePagesCount > pageIndex
            }
            return true
        },
        _setFocusedRowKeyByIndex(index) {
            const dataController = this.getController("data");
            if (this._isValidFocusedRowIndex(index)) {
                const rowIndex = Math.min(index - dataController.getRowIndexOffset(), dataController.items().length - 1);
                const focusedRowKey = dataController.getKeyByRowIndex(rowIndex);
                if ((0, _type.isDefined)(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
                    this.option("focusedRowKey", focusedRowKey)
                }
            }
        },
        _focusRowByKey(key) {
            if (!(0, _type.isDefined)(key)) {
                this._resetFocusedRow()
            } else {
                this._navigateToRow(key, true)
            }
        },
        _resetFocusedRow() {
            const focusedRowKey = this.option("focusedRowKey");
            const isFocusedRowKeyDefined = (0, _type.isDefined)(focusedRowKey);
            if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
                return
            }
            const keyboardController = this.getController("keyboardNavigation");
            if (isFocusedRowKeyDefined) {
                this.option("focusedRowKey", null)
            }
            keyboardController.setFocusedRowIndex(-1);
            this.option("focusedRowIndex", -1);
            this.getController("data").updateItems({
                changeType: "updateFocusedRow",
                focusedRowKey: null
            });
            keyboardController._fireFocusedRowChanged(void 0, -1)
        },
        _isValidFocusedRowIndex(rowIndex) {
            const dataController = this.getController("data");
            const row = dataController.getVisibleRows()[rowIndex];
            return !row || "data" === row.rowType || "group" === row.rowType
        },
        publicMethods: () => ["navigateToRow", "isRowFocused"],
        navigateToRow(key) {
            if (!this.isAutoNavigateToFocusedRow()) {
                this.option("focusedRowIndex", -1)
            }
            return this._navigateToRow(key)
        },
        _navigateToRow(key, needFocusRow) {
            const that = this;
            const dataController = that.getController("data");
            const isAutoNavigate = that.isAutoNavigateToFocusedRow();
            const d = new _deferred.Deferred;
            if (void 0 === key || !dataController.dataSource()) {
                return d.reject().promise()
            }
            const rowIndexByKey = that.getFocusedRowIndexByKey(key);
            if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
                that._navigateTo(key, d, needFocusRow)
            } else {
                dataController.getPageIndexByKey(key).done(pageIndex => {
                    if (pageIndex < 0) {
                        d.resolve(-1);
                        return
                    }
                    if (pageIndex === dataController.pageIndex()) {
                        dataController.reload().done(() => {
                            if (that.isRowFocused(key) && dataController.getRowIndexByKey(key) >= 0) {
                                d.resolve(that.getFocusedRowIndexByKey(key))
                            } else {
                                that._navigateTo(key, d, needFocusRow)
                            }
                        }).fail(d.reject)
                    } else {
                        dataController.pageIndex(pageIndex).done(() => {
                            that._navigateTo(key, d, needFocusRow)
                        }).fail(d.reject)
                    }
                }).fail(d.reject)
            }
            return d.promise()
        },
        _navigateTo(key, deferred, needFocusRow) {
            const visibleRowIndex = this.getController("data").getRowIndexByKey(key);
            const isVirtualRowRenderingMode = _m_utils.default.isVirtualRowRendering(this);
            const isAutoNavigate = this.isAutoNavigateToFocusedRow();
            if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
                this._navigateToVirtualRow(key, deferred, needFocusRow)
            } else {
                this._navigateToVisibleRow(key, deferred, needFocusRow)
            }
        },
        _navigateToVisibleRow(key, deferred, needFocusRow) {
            if (needFocusRow) {
                this._triggerUpdateFocusedRow(key, deferred)
            } else {
                const focusedRowIndex = this.getFocusedRowIndexByKey(key);
                this.getView("rowsView").scrollToRowElement(key, deferred).done(() => {
                    deferred.resolve(focusedRowIndex)
                })
            }
        },
        _navigateToVirtualRow(key, deferred, needFocusRow) {
            const dataController = this.getController("data");
            const rowsScrollController = dataController._rowsScrollController;
            const rowIndex = _m_utils.default.getIndexByKey(key, dataController.items(true));
            const scrollable = this.getView("rowsView").getScrollable();
            if (rowsScrollController && scrollable && rowIndex >= 0) {
                const focusedRowIndex = rowIndex + dataController.getRowIndexOffset(true);
                const offset = rowsScrollController.getItemOffset(focusedRowIndex);
                const triggerUpdateFocusedRow = () => {
                    if (dataController.totalCount() && !dataController.items().length) {
                        return
                    }
                    this.component.off("contentReady", triggerUpdateFocusedRow);
                    if (needFocusRow) {
                        this._triggerUpdateFocusedRow(key, deferred)
                    } else {
                        deferred.resolve(focusedRowIndex)
                    }
                };
                this.component.on("contentReady", triggerUpdateFocusedRow);
                this.getView("rowsView").scrollTopPosition(offset)
            } else {
                deferred.resolve(-1)
            }
        },
        _triggerUpdateFocusedRow(key, deferred) {
            const dataController = this.getController("data");
            const focusedRowIndex = this.getFocusedRowIndexByKey(key);
            if (this._isValidFocusedRowIndex(focusedRowIndex)) {
                let d;
                if (this.option("focusedRowEnabled")) {
                    dataController.updateItems({
                        changeType: "updateFocusedRow",
                        focusedRowKey: key
                    })
                } else {
                    d = this.getView("rowsView").scrollToRowElement(key)
                }(0, _deferred.when)(d).done(() => {
                    this.getController("keyboardNavigation").setFocusedRowIndex(focusedRowIndex);
                    deferred && deferred.resolve(focusedRowIndex)
                })
            } else {
                deferred && deferred.resolve(-1)
            }
        },
        getFocusedRowIndexByKey(key) {
            const dataController = this.getController("data");
            const loadedRowIndex = dataController.getRowIndexByKey(key, true);
            return loadedRowIndex >= 0 ? loadedRowIndex + dataController.getRowIndexOffset(true) : -1
        },
        _focusRowByKeyOrIndex() {
            const focusedRowKey = this.option("focusedRowKey");
            let currentFocusedRowIndex = this.option("focusedRowIndex");
            const keyboardController = this.getController("keyboardNavigation");
            const dataController = this.getController("data");
            if ((0, _type.isDefined)(focusedRowKey)) {
                const visibleRowIndex = dataController.getRowIndexByKey(focusedRowKey);
                if (visibleRowIndex >= 0) {
                    if (keyboardController._isVirtualScrolling()) {
                        currentFocusedRowIndex = visibleRowIndex + dataController.getRowIndexOffset()
                    }
                    keyboardController.setFocusedRowIndex(currentFocusedRowIndex);
                    this._triggerUpdateFocusedRow(focusedRowKey)
                } else {
                    this._navigateToRow(focusedRowKey, true).done(focusedRowIndex => {
                        if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
                            this._focusRowByIndex()
                        } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
                            keyboardController.setFocusedRowIndex(focusedRowIndex)
                        }
                    })
                }
            } else if (currentFocusedRowIndex >= 0) {
                this.getController("focus")._focusRowByIndex(currentFocusedRowIndex)
            }
        },
        isRowFocused(key) {
            const focusedRowKey = this.option("focusedRowKey");
            if ((0, _type.isDefined)(focusedRowKey)) {
                return (0, _common.equalByValue)(key, this.option("focusedRowKey"))
            }
            return
        },
        updateFocusedRow(_ref) {
            let {
                focusedRowKey: focusedRowKey
            } = _ref;
            const that = this;
            const focusedRowIndex = that._dataController.getRowIndexByKey(focusedRowKey);
            const rowsView = that.getView("rowsView");
            let $tableElement;
            let $mainRow;
            (0, _iterator.each)(rowsView.getTableElements(), (index, element) => {
                const isMainTable = 0 === index;
                $tableElement = (0, _renderer.default)(element);
                that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
                const $row = that._prepareFocusedRow({
                    changedItem: that._dataController.getVisibleRows()[focusedRowIndex],
                    $tableElement: $tableElement,
                    focusedRowIndex: focusedRowIndex
                });
                if (isMainTable) {
                    $mainRow = $row
                }
            });
            $mainRow && rowsView.scrollToElementVertically($mainRow)
        },
        _clearPreviousFocusedRow($tableElement, focusedRowIndex) {
            const $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter((_, focusedRow) => {
                const $focusedRowTable = (0, _renderer.default)(focusedRow).closest(".".concat(this.addWidgetPrefix("table")));
                return $tableElement.is($focusedRowTable)
            });
            $prevRowFocusedElement.removeClass("dx-row-focused").removeClass("dx-cell-focus-disabled").removeAttr("tabindex");
            $prevRowFocusedElement.children("td").removeAttr("tabindex");
            if (0 !== focusedRowIndex) {
                const $firstRow = (0, _renderer.default)(this.getView("rowsView").getRowElement(0));
                $firstRow.removeClass("dx-cell-focus-disabled").removeAttr("tabIndex")
            }
        },
        _prepareFocusedRow(options) {
            let $row;
            const {
                changedItem: changedItem
            } = options;
            if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
                const {
                    focusedRowIndex: focusedRowIndex
                } = options;
                const {
                    $tableElement: $tableElement
                } = options;
                const tabIndex = this.option("tabindex") || 0;
                const rowsView = this.getView("rowsView");
                $row = (0, _renderer.default)(rowsView._getRowElements($tableElement).eq(focusedRowIndex));
                $row.addClass("dx-row-focused").attr("tabindex", tabIndex)
            }
            return $row
        }
    };
    return members
}());
const focusModule = {
    defaultOptions: () => ({
        focusedRowEnabled: false,
        autoNavigateToFocusedRow: true,
        focusedRowKey: null,
        focusedRowIndex: -1,
        focusedColumnIndex: -1
    }),
    controllers: {
        focus: FocusController
    },
    extenders: {
        controllers: {
            keyboardNavigation: {
                init() {
                    const rowIndex = this.option("focusedRowIndex");
                    const columnIndex = this.option("focusedColumnIndex");
                    this.createAction("onFocusedRowChanging", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedRowChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedCellChanging", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedCellChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.callBase();
                    this.setRowFocusType();
                    this._focusedCellPosition = {};
                    if ((0, _type.isDefined)(rowIndex) && rowIndex >= 0) {
                        this._focusedCellPosition.rowIndex = rowIndex
                    }
                    if ((0, _type.isDefined)(columnIndex) && columnIndex >= 0) {
                        this._focusedCellPosition.columnIndex = columnIndex
                    }
                },
                setFocusedRowIndex(rowIndex) {
                    this.callBase(rowIndex);
                    this.option("focusedRowIndex", rowIndex)
                },
                setFocusedColumnIndex(columnIndex) {
                    this.callBase(columnIndex);
                    this.option("focusedColumnIndex", columnIndex)
                },
                _escapeKeyHandler(eventArgs, isEditing) {
                    if (isEditing || !this.option("focusedRowEnabled")) {
                        return this.callBase(eventArgs, isEditing)
                    }
                    if (this.isCellFocusType()) {
                        this.setRowFocusType();
                        this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
                        return true
                    }
                    return false
                },
                _updateFocusedCellPosition($cell, direction) {
                    const position = this.callBase($cell, direction);
                    if (position && position.columnIndex >= 0) {
                        this._fireFocusedCellChanged($cell)
                    }
                }
            },
            editorFactory: {
                renderFocusOverlay($element, isHideBorder) {
                    const keyboardController = this.getController("keyboardNavigation");
                    const focusedRowEnabled = this.option("focusedRowEnabled");
                    const editingController = this.getController("editing");
                    let $cell;
                    if (!focusedRowEnabled || !(null === keyboardController || void 0 === keyboardController ? void 0 : keyboardController.isRowFocusType()) || editingController.isEditing()) {
                        this.callBase($element, isHideBorder)
                    } else if (focusedRowEnabled) {
                        const isRowElement = "row" === keyboardController._getElementType($element);
                        if (isRowElement && !$element.hasClass("dx-row-focused")) {
                            $cell = keyboardController.getFirstValidCellInRow($element);
                            keyboardController.focus($cell)
                        }
                    }
                }
            },
            columns: {
                getSortDataSourceParameters(_, sortByKey) {
                    let result = this.callBase.apply(this, arguments);
                    const dataController = this.getController("data");
                    const dataSource = dataController._dataSource;
                    const store = dataController.store();
                    let key = store && store.key();
                    const remoteOperations = dataSource && dataSource.remoteOperations() || {};
                    const isLocalOperations = Object.keys(remoteOperations).every(operationName => !remoteOperations[operationName]);
                    if (key && (this.option("focusedRowEnabled") && false !== this.getController("focus").isAutoNavigateToFocusedRow() || sortByKey)) {
                        key = Array.isArray(key) ? key : [key];
                        const notSortedKeys = key.filter(key => !this.columnOption(key, "sortOrder"));
                        if (notSortedKeys.length) {
                            result = result || [];
                            if (isLocalOperations) {
                                result.push({
                                    selector: dataSource.getDataIndexGetter(),
                                    desc: false
                                })
                            } else {
                                notSortedKeys.forEach(notSortedKey => result.push({
                                    selector: notSortedKey,
                                    desc: false
                                }))
                            }
                        }
                    }
                    return result
                }
            },
            data: {
                _applyChange(change) {
                    if (change && "updateFocusedRow" === change.changeType) {
                        return
                    }
                    return this.callBase.apply(this, arguments)
                },
                _fireChanged(e) {
                    this.callBase(e);
                    if (this.option("focusedRowEnabled") && this._dataSource) {
                        const isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
                        const isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
                        if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
                            this._updatePageIndexes();
                            this._updateFocusedRow(e)
                        } else if ("append" === e.changeType || "prepend" === e.changeType) {
                            this._updatePageIndexes()
                        } else if ("update" === e.changeType && e.repaintChangesOnly) {
                            this._updateFocusedRow(e)
                        }
                    }
                },
                _updatePageIndexes() {
                    const prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
                    const renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
                    this._lastRenderingPageIndex = renderingPageIndex;
                    this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex
                },
                isPagingByRendering() {
                    return this._isPagingByRendering
                },
                _updateFocusedRow(e) {
                    const operationTypes = e.operationTypes || {};
                    const focusController = this.getController("focus");
                    const {
                        reload: reload,
                        fullReload: fullReload,
                        pageIndex: pageIndex,
                        paging: paging
                    } = operationTypes;
                    const keyboardController = this.getController("keyboardNavigation");
                    const isVirtualScrolling = keyboardController._isVirtualScrolling();
                    const pagingWithoutVirtualScrolling = paging && !isVirtualScrolling;
                    const focusedRowKey = this.option("focusedRowKey");
                    const isAutoNavigate = focusController.isAutoNavigateToFocusedRow();
                    const isReload = reload && false === pageIndex;
                    if (isReload && !fullReload && (0, _type.isDefined)(focusedRowKey)) {
                        focusController._navigateToRow(focusedRowKey, true).done(focusedRowIndex => {
                            if (focusedRowIndex < 0) {
                                focusController._focusRowByIndex(void 0, operationTypes)
                            }
                        })
                    } else if (pagingWithoutVirtualScrolling && isAutoNavigate) {
                        const rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
                        const focusedRowIndex = this.option("focusedRowIndex");
                        const isValidRowIndexByKey = rowIndexByKey >= 0;
                        const isValidFocusedRowIndex = focusedRowIndex >= 0;
                        const isSameRowIndex = focusedRowIndex === rowIndexByKey;
                        if (isValidFocusedRowIndex && (isSameRowIndex || !isValidRowIndexByKey)) {
                            focusController._focusRowByIndex(focusedRowIndex, operationTypes)
                        }
                    } else if (pagingWithoutVirtualScrolling && !isAutoNavigate && this.getRowIndexByKey(focusedRowKey) < 0) {
                        this.option("focusedRowIndex", -1)
                    } else if (operationTypes.fullReload) {
                        focusController._focusRowByKeyOrIndex()
                    }
                },
                getPageIndexByKey(key) {
                    const that = this;
                    const d = new _deferred.Deferred;
                    that.getGlobalRowIndexByKey(key).done(globalIndex => {
                        d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1)
                    }).fail(d.reject);
                    return d.promise()
                },
                getGlobalRowIndexByKey(key) {
                    if (this._dataSource.group()) {
                        return this._calculateGlobalRowIndexByGroupedData(key)
                    }
                    return this._calculateGlobalRowIndexByFlatData(key)
                },
                _calculateGlobalRowIndexByFlatData(key, groupFilter, useGroup) {
                    const that = this;
                    const deferred = new _deferred.Deferred;
                    const dataSource = that._dataSource;
                    if (Array.isArray(key) || (0, _m_editing_utils.isNewRowTempKey)(key)) {
                        return deferred.resolve(-1).promise()
                    }
                    let filter = that._generateFilterByKey(key);
                    dataSource.load({
                        filter: that._concatWithCombinedFilter(filter),
                        skip: 0,
                        take: 1
                    }).done(data => {
                        if (data.length > 0) {
                            filter = that._generateOperationFilterByKey(key, data[0], useGroup);
                            dataSource.load({
                                filter: that._concatWithCombinedFilter(filter, groupFilter),
                                skip: 0,
                                take: 1,
                                requireTotalCount: true
                            }).done((_, extra) => {
                                deferred.resolve(extra.totalCount)
                            })
                        } else {
                            deferred.resolve(-1)
                        }
                    });
                    return deferred.promise()
                },
                _concatWithCombinedFilter(filter, groupFilter) {
                    const combinedFilter = this.getCombinedFilter();
                    return _m_utils.default.combineFilters([filter, combinedFilter, groupFilter])
                },
                _generateBooleanFilter(selector, value, sortInfo) {
                    const {
                        desc: desc
                    } = sortInfo;
                    switch (true) {
                        case false === value && desc:
                            return [selector, "=", true];
                        case false === value && !desc:
                            return [selector, "=", null];
                        case true === value && !desc:
                        case !(0, _type.isBoolean)(value) && desc:
                            return [selector, "<>", value];
                        default:
                            return
                    }
                },
                _generateOperationFilterByKey(key, rowData, useGroup) {
                    const that = this;
                    const dateSerializationFormat = that.option("dateSerializationFormat");
                    const isRemoteFiltering = that._dataSource.remoteOperations().filtering;
                    const isRemoteSorting = that._dataSource.remoteOperations().sorting;
                    let filter = that._generateFilterByKey(key, "<");
                    let sort = that._columnsController.getSortDataSourceParameters(!isRemoteFiltering, true);
                    if (useGroup) {
                        const group = that._columnsController.getGroupDataSourceParameters(!isRemoteFiltering);
                        if (group) {
                            sort = sort ? group.concat(sort) : group
                        }
                    }
                    if (sort) {
                        sort.slice().reverse().forEach(sortInfo => {
                            const {
                                selector: selector,
                                desc: desc,
                                compare: compare
                            } = sortInfo;
                            const {
                                getter: getter,
                                rawValue: rawValue,
                                safeValue: safeValue
                            } = _m_focus_utils.UiGridCoreFocusUtils.getSortFilterValue(sortInfo, rowData, {
                                isRemoteFiltering: isRemoteFiltering,
                                dateSerializationFormat: dateSerializationFormat,
                                getSelector: selector => that._columnsController.columnOption(selector, "selector")
                            });
                            filter = [
                                [selector, "=", safeValue], "and", filter
                            ];
                            if (null === rawValue || (0, _type.isBoolean)(rawValue)) {
                                const booleanFilter = that._generateBooleanFilter(selector, safeValue, desc);
                                if (booleanFilter) {
                                    filter = [booleanFilter, "or", filter]
                                }
                            } else {
                                const filterOperation = desc ? ">" : "<";
                                let sortFilter;
                                if (compare && !isRemoteSorting) {
                                    sortFilter = data => {
                                        if ("<" === filterOperation) {
                                            return compare(rawValue, getter(data)) >= 1
                                        }
                                        return compare(rawValue, getter(data)) <= -1
                                    }
                                } else {
                                    sortFilter = [selector, filterOperation, safeValue];
                                    if (!desc) {
                                        sortFilter = [sortFilter, "or", [selector, "=", null]]
                                    }
                                }
                                filter = [sortFilter, "or", filter]
                            }
                        })
                    }
                    return filter
                },
                _generateFilterByKey(key, operation) {
                    const dataSourceKey = this._dataSource.key();
                    let filter = [];
                    if (!operation) {
                        operation = "="
                    }
                    if (Array.isArray(dataSourceKey)) {
                        for (let i = 0; i < dataSourceKey.length; ++i) {
                            const keyPart = key[dataSourceKey[i]];
                            if (keyPart) {
                                if (filter.length > 0) {
                                    filter.push("and")
                                }
                                filter.push([dataSourceKey[i], operation, keyPart])
                            }
                        }
                    } else {
                        filter = [dataSourceKey, operation, key]
                    }
                    return filter
                },
                _getLastItemIndex() {
                    return this.items(true).length - 1
                }
            },
            editing: {
                _deleteRowCore(rowIndex) {
                    const deferred = this.callBase.apply(this, arguments);
                    const dataController = this.getController("data");
                    const rowKey = dataController.getKeyByRowIndex(rowIndex);
                    deferred.done(() => {
                        const rowIndex = dataController.getRowIndexByKey(rowKey);
                        const visibleRows = dataController.getVisibleRows();
                        if (-1 === rowIndex && !visibleRows.length) {
                            this.getController("focus")._resetFocusedRow()
                        }
                    })
                }
            }
        },
        views: {
            rowsView: {
                _createRow(row) {
                    const $row = this.callBase.apply(this, arguments);
                    if (this.option("focusedRowEnabled") && row) {
                        if (this.getController("focus").isRowFocused(row.key)) {
                            $row.addClass("dx-row-focused")
                        }
                    }
                    return $row
                },
                _checkRowKeys(options) {
                    this.callBase.apply(this, arguments);
                    if (this.option("focusedRowEnabled") && this.option("dataSource")) {
                        const store = this._dataController.store();
                        if (store && !store.key()) {
                            this._dataController.fireError("E1042", "Row focusing")
                        }
                    }
                },
                _update(change) {
                    if ("updateFocusedRow" === change.changeType) {
                        if (this.option("focusedRowEnabled")) {
                            this.getController("focus").updateFocusedRow(change)
                        }
                    } else {
                        this.callBase(change)
                    }
                },
                updateFocusElementTabIndex($cellElements, preventScroll) {
                    if (this.option("focusedRowEnabled")) {
                        this._setFocusedRowElementTabIndex(preventScroll)
                    } else {
                        this.callBase($cellElements)
                    }
                },
                _setFocusedRowElementTabIndex(preventScroll) {
                    const focusedRowKey = this.option("focusedRowKey");
                    const tabIndex = this.option("tabIndex") || 0;
                    const dataController = this._dataController;
                    const columnsController = this._columnsController;
                    let rowIndex = dataController.getRowIndexByKey(focusedRowKey);
                    let columnIndex = this.option("focusedColumnIndex");
                    const $row = this._findRowElementForTabIndex();
                    if (!(0, _type.isDefined)(this._scrollToFocusOnResize)) {
                        this._scrollToFocusOnResize = () => {
                            this.scrollToElementVertically(this._findRowElementForTabIndex());
                            this.resizeCompleted.remove(this._scrollToFocusOnResize)
                        }
                    }
                    $row.attr("tabIndex", tabIndex);
                    if (rowIndex >= 0 && !preventScroll) {
                        if (columnIndex < 0) {
                            columnIndex = 0
                        }
                        rowIndex += dataController.getRowIndexOffset();
                        columnIndex += columnsController.getColumnIndexOffset();
                        this.getController("keyboardNavigation").setFocusedCellPosition(rowIndex, columnIndex);
                        if (this.getController("focus").isAutoNavigateToFocusedRow()) {
                            const dataSource = dataController.dataSource();
                            const operationTypes = dataSource && dataSource.operationTypes();
                            if (operationTypes && !operationTypes.paging && !dataController.isPagingByRendering()) {
                                this.resizeCompleted.remove(this._scrollToFocusOnResize);
                                this.resizeCompleted.add(this._scrollToFocusOnResize)
                            }
                        }
                    }
                },
                _findRowElementForTabIndex() {
                    const focusedRowKey = this.option("focusedRowKey");
                    const rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
                    return (0, _renderer.default)(this.getRowElement(rowIndex >= 0 ? rowIndex : 0))
                },
                scrollToRowElement(key) {
                    const rowIndex = this.getController("data").getRowIndexByKey(key);
                    const $row = (0, _renderer.default)(this.getRow(rowIndex));
                    return this.scrollToElementVertically($row)
                },
                scrollToElementVertically($row) {
                    const scrollable = this.getScrollable();
                    if (scrollable && $row.length) {
                        const position = scrollable.getScrollElementPosition($row, "vertical");
                        return this.scrollTopPosition(position)
                    }
                    return (new _deferred.Deferred).resolve()
                },
                scrollTopPosition(scrollTop) {
                    const d = new _deferred.Deferred;
                    const scrollable = this.getScrollable();
                    if (scrollable) {
                        const currentScrollTop = scrollable.scrollTop();
                        const scrollHandler = () => {
                            scrollable.off("scroll", scrollHandler);
                            d.resolve()
                        };
                        if (scrollTop !== currentScrollTop) {
                            scrollable.on("scroll", scrollHandler);
                            this._dataController.resetFilterApplying();
                            scrollable.scrollTo({
                                top: scrollTop
                            });
                            return d.promise()
                        }
                    }
                    return d.resolve()
                }
            }
        }
    }
};
exports.focusModule = focusModule;
